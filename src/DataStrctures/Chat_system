MUST-HAVE Functional Requirements

(Core features without which chat cannot work)

Send & receive messages (real-time).
Message ordering inside a conversation.
Message delivery status (sent/delivered).
Store and sync chat history across devices.
User authentication (login).
Notifications for new messages.
Basic presence (online/offline).

Without these, it is not a usable chat system.

âœ… MUST-HAVE Non-Functional Requirements

(Minimum engineering guarantees)
Low latency messaging (<200 ms).
High availability (no downtime).
Durability â€” messages must never be lost.
Scalability â€” handle growing number of users.
Security â€” encrypted communication.
Fault tolerance â€” system keeps working if servers fail.

// Things to dicuss
1. communication protocol - websockets
2. stateless services -> Service Discovery, auth service, group managemnet, user profile
3. stateful service -> chat service
4. Scalability in chat system
5. How to ensure message is delivered?
6. storage (raed 10:1) more read (frequent chats/ non frequent chats)
7. data Models
8. Avoid data duplicacy (message id which is unique) genertate UUID

These are essential to avoid message loss, lag, or outages.

                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚        API Gateway            â”‚
                â”‚ (rate-limit, auth redirect)   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           |
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        |                  |                  |
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Auth Service  â”‚   â”‚User Profile  â”‚   â”‚Service Discoveryâ”‚
â”‚(stateless)   â”‚   â”‚(stateless)   â”‚   â”‚(stateless)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        |
        | WebSocket Upgrade
        v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Chat Gateway Layer     â”‚  <â€” Stateless WS termination
â”‚(WS connections, routing) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        |
        v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Chat Service (Stateful)â”‚ <â€” holds active user sessions
â”‚  - session store          â”‚
â”‚  - message delivery       â”‚
â”‚  - ordering               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        |
        |  enqueue messages
        v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Message Queue (Kafka)   â”‚
â”‚ topics: chat.write,      â”‚
â”‚ group.fanout, receipts   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        |
        v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Storage Layer               â”‚
â”‚  - Message Store (Cassandra) â”‚
â”‚  - Group Store               â”‚
â”‚  - User State Store (Redis)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        |
        v
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚Push Service â”‚ â†’ APNS/Firebase
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

-------What are WebSockets?--------

WebSockets are a full-duplex, persistent connection between client and server.
â€œFull-duplexâ€ â†’ both client and server can send messages anytime.
â€œPersistentâ€ â†’ connection stays open (unlike HTTP which closes after each request).
Think of it as: a phone call vs. sending letters.

âœ… Why WebSockets in a Chat System?
1. Real-time messaging
Chat apps must push messages instantly.
HTTP polling is slow; WebSockets push messages immediately.
WebSockets = instant message delivery.

2. Low latency
No need to create new HTTP connections repeatedly.
Once connected, sending a message is extremely fast.

3. Real-time presence updates
Online/offline, typing indicators, read receipts â€” all need live updates.
Presence servers use WebSockets to broadcast state.

4. Efficient for high QPS
Instead of thousands of HTTP requests (polling), 1 persistent connection handles everything.
Less CPU usage.
Less bandwidth.
Better scalability.

5. Server can push messages
In HTTP, client must pull.
In WebSockets, server can push when new message arrives.
â€œMessage arrives â†’ server pushes â†’ client displays instantly.â€

6. Used by all major chat systems
WhatsApp, Messenger, Slack, Teams â€” all rely on WebSockets (or long-lived TCP connections).

------- Stateless Service ---------
A stateless service does NOT store any user/session data inside the serverâ€™s memory between requests.
Every request is independent.
Server does not â€œrememberâ€ anything about previous requests.
All state is stored in DB / Cache / Token / External storage, not inside the app server.

Example:

If user X hits Server A now and Server B next, both must behave the same â†’ no dependency on in-memory session.
Stateless servers scale horizontally very easily.

1)Authentication Service (Stateless)
What:
Handles login, token creation (JWT), session validation.

Why stateless:
Because JWT contains all user info.
Auth server doesnâ€™t need to keep session in memory.

2) User Profile Service (Stateless)
What:
Stores user info (name, photo, status, settings).

Why stateless:
Profile data is in a DB (SQL/NoSQL).
Service only fetches/updates records â†’ no local state.

How:
Client requests /user/{id}
Service retrieves from DB/Cache
Returns profile

3) Group Management Service (Stateless)
What:
Manages group creation, members, permissions.

Why stateless:
Groups + membership stored in DB.
Service only processes â€œadd user/remove userâ€.

How:
When user creates a group â†’
Group service inserts a row into DB or updates member-list.
Stateless â†’ any instance can handle group operations.

4) Service Discovery (Stateless)
What:
In a chat system, there are hundreds or thousands of Chat/WebSocket servers running.
Clients need to know which server to connect to.
Service Discovery makes this automatic:
It tracks:
Which chat server instances are alive
Their IP/port
Their load (connections, CPU, memory)
Their region (India, US, EUâ€¦)
Whether they are healthy

Examples of service discovery systems:
Zookeeper

ğŸŒŸ Why do we need this?
Because chat systems have:
Millions of concurrent WebSocket connections
WebSocket is a long-lived connection
Servers fail, restart, scale up/down frequently
Clients canâ€™t hardcode server addresses.
Service Discovery provides dynamic, real-time routing.

------> StateFul Server <---------
-> Chat server
Why Chat Servers MUST Be Stateful
A chat server is the server that holds every userâ€™s live WebSocket connection.
When a user opens the app â†’ the client establishes a WebSocket:
Client  â†”  Chat Server

This connection is not stateless like REST.
The server must keep in memory:
socket ID
user ID

which chat rooms the user is subscribed to
delivery cursor (last delivered message for that socket)
unread message counters (sometimes)
heartbeat timestamp

WebSocket event handlers
â†’ These are all in-memory runtime data, not stored in DB.
Therefore:
âœ” Chat servers are stateful per connection,

---- Simple one chat flow ---------

Step 1: User A Connected (State Stored on Server-1)
User A â”€â”€â”€â”€â”€â”€ WebSocket â”€â”€â”€â”€â”€â–º Chat Server #1
                                |
                                | (state)
                                | socket=A-s12
                                | user=A
                                | rooms=[roomX]

ğŸ”¹ Step 2: User B Connected (State Stored on Server-3)
User B â”€â”€â”€â”€â”€â”€ WebSocket â”€â”€â”€â”€â”€â–º Chat Server #3
                                |
                                | (state)
                                | socket=B-s99
                                | user=B
                                | rooms=[roomX]


Each client is pinned to a different chat server.

ğŸ”¹ Step 3: User A Sends Message â€œHiâ€
User A
   |
   | send("Hi")
   â–¼
Chat Server #1
   |
   | 1. Appends to message queue (Kafka)
   | 2. Stores in DB
   | 3. Finds which server User B is attached to
   â–¼
Service Discovery (Redis)
(user B â†’ Chat Server #3)

ğŸ”¹ Step 4: Chat Server #1 â†’ Chat Server #3 (Fanout)
Chat Server #1
     |
     | push(B, "Hi")
     â–¼
Chat Server #3
     |
     | deliver to B-s99 socket
     â–¼
User B
----> Scalability <---------
A chat system is real-time.
Millions of users â†’ millions of WebSocket connections â†’ millions of messages per second.
A single server cannot hold:
all user sockets
all incoming messages
all fan-out delivery

So we scale by:

âœ” Many chat servers (stateful)
âœ” Message Queue for buffering, ordering, durability
âœ” Distributed storage (Cassandra / DynamoDB / MongoDB)
âœ” Redis for online presence + routing

------>message queues<--------
Where Do Message Queues Come Into the System?
Message queues decouple message SEND from DELIVERY.
When a user sends a message:
Client A â†’ Chat Server A
Chat Server A â†’ Kafka topic ("messages")

Chat Server A does NOT directly deliver to User B, because:
slow receivers will slow down the system
cross-server communication gets messy
messages must be durable (no loss)
ordering must be preserved per chat room
So Kafka (or any queue) becomes the source of truth for delivery.
User A
   |
   v
Chat Server #1
   |
   | 1. Writes message to Kafka (async)
   v
+---------------+
|   Kafka MQ    |
| (partitioned) |
+---------------+
   |
   | 2. Chat Server #3 consumes (server B is attached here)
   v
Chat Server #3
   |
   | 3. Delivers over WebSocket
   v
User B


------->How to Ensure Message Is Delivered--------------
We use Delivery Guarantee Levels:

1) At-least-once Delivery (most chat apps use this)
Kafka stores message
Chat server attempts delivery
If client does not ACK â†’ retry
Could cause duplicates â†’ handle via idempotency

2) Exactly-once Delivery (rare; expensive)
Requires message ID + deduplication + transactional log
WhatsApp, Slack use dedupe tokens or msgId tables
How Delivery Works (ACK flow)
Chat Server #3  â†’ sends message â†’  Client B
Chat Server #3  â† receives ACK  â† Client B

If server never receives ACK â†’ it retries.

-----> What If Client B Turns Off Network? <---------
This is the most important real-world scenario.

Client B disconnects (network killed)
Chat Server #3 detects:
WebSocket closed
Heartbeat missing
Mark user as offline

What happens to messages?
They go to "offline message store" (DB or Redis or Kafka offset).

Message flow in this case:
User A  â†’ Chat Server #1 â†’ Kafka â†’ DB (stored)
Client B offline â†’ delivery pending


When Client B reconnects:

Client B â†’ Chat Server #2 (may be different server)
Chat Server #2 â†’ read pending messages from DB/Kafka
Chat Server #2 â†’ deliver sequentially
Client B â†’ send ACKs


This ensures:

âœ” Message never lost
âœ” Delivery resumes when the user returns
âœ” Ordering preserved (using Kafka topic partition per chat)

------> Strage <---------
How Storage Works in a Real-Time Chat System
A chat system stores two kinds of data:
A) Hot Data (recent messages)
Stored in Redis / Memory Cache
Fast reads for "recent 50â€“100 messages"
Low latency (sub-millisecond)
Used when a user opens a chat window

Chat Server
   |
   v
Redis (recent messages)

B) Cold Data (old chat history)
Stored in a distributed database:
âœ” Cassandra
âœ” DynamoDB
âœ” MongoDB
âœ” HBase

Append-only model â†’ perfect for chat
Tuned for very high write throughput

Chat Server
   |
   v
Cassandra Cluster (long-term storage)

â­ 2. Why Two Layers? (Hot + Cold Storage)
Because:
Recent messages = most frequently read
Old messages = very large volume & rarely read
If you put all messages in Redis â†’ memory explosion.
If you put all messages in Cassandra â†’ read latency too high.

So we use:
âœ” Redis â†’ fast reads for recent, small set
âœ” Cassandra â†’ slow reads but infinite history capacity
â­ 3. Stick Diagram â€” Storage Flow
User A sends message
    |
    v
Chat Server
    |
+-----------+              +----------------+
|   Redis   |  <- recent   |   Cassandra    |
| (cache)   |              | (full history) |
+-----------+              +----------------+

Redis stores recent N messages per chat.
Cassandra stores all messages forever.

â­ 4. Real-Time Write Flow
When a new message arrives:
Chat Server
   |
   â”œâ”€â”€ 1. Write to Kafka (durability)
   |
   â”œâ”€â”€ 2. Append to Cassandra (persistent storage)
   |
   â””â”€â”€ 3. Write to Redis (recent cache)

All three happen asynchronously to keep latency low.
â­ 5. Real-Time Read Flow
When client opens the chat:
Client â†’ Chat Server â†’ Redis (get recent 50â€“100 messages)
If user scrolls up (fetch old messages):
Redis miss â†’ Fetch older pages from Cassandra

â­ 6. What Is the Read / Write Ratio in Chat Systems?
Real-world ratio:
Writes are low, reads are VERY high
Example (WhatsApp, Facebook Messenger):
1 write per message
8â€“15 reads per message
(sender sees it, receiver sees, app opens, reopens, syncs, backups, etc.)

So:
Read : Write ratio â‰ˆ 10 : 1
This is exactly why:

Redis cache is critical
Cassandra is optimized for fast writes but slower reads
Messages must be query-efficient in a time-sorted way

â­ 7. How Horizontal Scaling Works in Storage
A) Cassandra horizontal scaling
Cassandra partitions data using:
partitionKey = chatId

Messages are stored in sorted order by timestamp.
Add more nodes â†’ Cassandra automatically rebalances.
More nodes = more write throughput + more storage capacity

Cassandra Cluster
 â”œâ”€â”€ Node1: chatId 0â€“1000
 â”œâ”€â”€ Node2: chatId 1001â€“2000
 â”œâ”€â”€ Node3: chatId 2001â€“3000
 â””â”€â”€ ...
B) Redis horizontal scaling (sharding)
Shard1 â†’ chatId % 3 = 0
Shard2 â†’ chatId % 3 = 1
Shard3 â†’ chatId % 3 = 2

Add more shards â†’ distribute keys â†’ increase memory and throughput.

â­ 8. Why Do Users Only See Recent Messages Quickly?
Because recent messages are served from:
âœ” Redis
âœ” Local memory cache (on Chat Server)
âœ” Kafka consumer offsets

These guarantee sub-millisecond access.
Older messages require a database lookup, which is slower.
Real chat apps assume:
95% of reads are for the recent conversation (last few minutes).
So system is built around this usage pattern.

â­ 9. Combined Stick Diagram â€” Complete Storage Architecture
              +-----------------------+
Client A ---> |     Chat Server       |
              +-----------------------+
                   |       |
                   |       v
                   |   Redis Cache (hot)
                   |
                   v
             Kafka (durable log)
                   |
                   v
            Cassandra / DynamoDB (cold)

-------> Data Models <------
Below is a **clean, interview-ready** answer covering:

âœ” Data models for **1:1 chat**
âœ” Data models for **group chat**
âœ” How to **avoid duplicate messages**
âœ” How this is handled in real chat systems (WhatsApp, Slack, MS Teams)
âœ” Simple stick diagrams

---

# â­ 1. Data Model for **1:1 Chat** (Direct Messages)
conversationId = hash(min(A,B) + "#" + max(A,B))

## âœ” **1:1 Message Table**

### **Table: DirectMessages**

| Column         | Type          | Notes                   |
| -------------- | ------------- | ----------------------- |
| conversationId | string        | Partition key           |
| messageId      | string (UUID) | Unique per message      |
| senderId       | string        | Who sent                |
| receiverId     | string        | Who receives            |
| content        | text/json     | Message body            |
| createdAt      | timestamp     | Sorted clustering key   |
| status         | enum          | sent / delivered / read |

### **Primary Key**

```
PRIMARY KEY (conversationId, createdAt)
```

Why?

* All messages for a 1:1 chat go into a single partition.
* Sorted by timestamp â†’ perfect for chat scrolling.

---

# â­ Stick Diagram â€” 1:1 Chat Storage

```
ConversationId: hash(A#B)
   |
   v
+--------------------------------+
|  DirectMessages (Partition)    |
+--------------------------------+
| msg1 | A â†’ B | "hi"   | t1     |
| msg2 | B â†’ A | "yo"   | t2     |
| msg3 | A â†’ B | "okay" | t3     |
+--------------------------------+
```

---

# â­ 2. Data Model for **Group Chat**
Group chats can have **10 â†’ 10,000 members**, so design is different.
### **A) Group Metadata Table**
### Table: Groups

| Column    | Type      |
| --------- | --------- |
| groupId   | string    |
| name      | string    |
| createdAt | timestamp |

---

### **B) Group Members Table**

### Table: GroupMembers

| Column   | Type           |
| -------- | -------------- |
| groupId  | string         |
| userId   | string         |
| role     | admin / member |
| joinedAt | timestamp      |

**Primary key:** (groupId, userId)

---

### **C) Group Messages Table**

### Table: GroupMessages

| Column    | Type                       |
| --------- | -------------------------- |
| groupId   | string (partition key)     |
| messageId | string (UUID)              |
| senderId  | string                     |
| content   | text                       |
| createdAt | timestamp (clustering key) |

**Primary Key:**

```
PRIMARY KEY (groupId, createdAt, messageId)
```

---

# â­ Stick Diagram â€” Group Chat Storage

```
GroupId: "cricket-fans"
   |
   v
+----------------------------+
|      GroupMessages         |
+----------------------------+
| msg1 | Bob | "hello" | t1  |
| msg2 | Ana | "match?"| t2  |
| msg3 | Raj | "yes!"  | t3  |
+----------------------------+
```

---

# â­ 3. How Do We Avoid Sending Duplicate Messages?
Duplicate messages can happen when:
* Network retry
* WebSocket reconnect
* Client resends on failure
* Server crashes mid-send
* Queue consumer retries

To prevent duplicates, chat systems use **idempotency**.

---

# â­ Duplicate Prevention Mechanisms
1ï¸âƒ£ Unique messageId (UUID) generated by client or server**

Every message contains:
messageId = "550e8400-e29b-41d4-a716-446655440000"


When a chat server receives a message, it checks:

Has messageId been stored before?

If YES â†’ ignore.
If NO â†’ process normally.

### Table to track processed messages:

```
SeenMessages
------------
messageId | status
```

Or store messageId in Redis with TTL.

---

# â­ 2ï¸âƒ£ Kafka Exactly-Once Partition Guarantee

For writes:
* Each user/chat is mapped to a **Kafka partition**.
* Kafka guarantees **ordering** and **at-least-once** delivery.
* Chat servers must deduplicate using messageId.

---

# â­ 3ï¸âƒ£ Server-side Deduplication Logic


Client â†’ ChatServer â†’ â€œprocess messageâ€:
    |
    | Check Redis: is messageId seen?
    |
   Yes â†’ DROP (duplicate)
   No  â†’ Store in Redis + Write to DB + fan-out
```

# â­ Stick Diagram â€” Duplicate Prevention

```
           +----------------------+
Client --->| Chat Server          |
           +----------------------+
                     |
                     | check messageId in Redis
                     v
           +----------------------+
           | Redis: SeenMessages  |
           +----------------------+
                     |
      duplicate? --->| yes â†’ drop
                     |
                     v
     No â†’ Write to DB & push to Kafka
```


# â­ 4. Why We MUST Deduplicate

Because:

* WebSocket reconnect may cause **retries**
* Mobile apps send last unsent message again
* Kafka retries on consumer crash
* Server restarts mid-write
* Network dropping ACKs triggers resend

Without dedupe â†’ â€œHi Hi Hiâ€ problem.


> Each message is assigned a global messageId (UUID).
> Chat server checks Redis/DB to ensure the messageId hasnâ€™t been processed.
> This guarantees idempotency and prevents duplicates even under retries or failures.



