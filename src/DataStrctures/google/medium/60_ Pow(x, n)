It sounds like you want to implement a function that calculates 
ğ‘¥
ğ‘›
x 
n
  (x raised to the power of n) for any integer 
ğ‘›
n, where:

ğ‘¥
x can be any number (not zero).
ğ‘›
n is an integer (positive, negative, or zero).
Hereâ€™s how we can approach this:

Approach: Fast Exponentiation (Exponentiation by Squaring)
This approach efficiently calculates 
ğ‘¥
ğ‘›
x 
n
  in 
ğ‘‚
(
log
â¡
ğ‘›
)
O(logn) time by:

Dividing the power calculation into smaller components recursively.
Utilizing the property that:
If 
ğ‘›
n is even: 
ğ‘¥
ğ‘›
=
(
ğ‘¥
ğ‘›
/
2
)
Ã—
(
ğ‘¥
ğ‘›
/
2
)
x 
n
 =(x 
n/2
 )Ã—(x 
n/2
 ).
If 
ğ‘›
n is odd: 
ğ‘¥
ğ‘›
=
ğ‘¥
Ã—
(
ğ‘¥
(
ğ‘›
âˆ’
1
)
/
2
)
Ã—
(
ğ‘¥
(
ğ‘›
âˆ’
1
)
/
2
)
x 
n
 =xÃ—(x 
(nâˆ’1)/2
 )Ã—(x 
(nâˆ’1)/2
 ).
For negative values of 
ğ‘›
n, we compute 
ğ‘¥
âˆ’
ğ‘›
=
1
ğ‘¥
ğ‘›
x 
âˆ’n
 = 
x 
n
 
1
â€‹
 .
This approach is much faster than a naive 
ğ‘‚
(
ğ‘›
)
O(n) multiplication, making it ideal for large values of 
ğ‘›
n.

Code Implementation (JavaScript)
javascript
Copy code
function power(x, n) {
    // Base cases
    if (n === 0) return 1;           // x^0 = 1 for any x
    if (n < 0) return 1 / power(x, -n);  // Handle negative powers

    // Recursively calculate power using exponentiation by squaring
    const halfPower = power(x, Math.floor(n / 2));

    // If n is even, return halfPower * halfPower
    if (n % 2 === 0) {
        return halfPower * halfPower;
    } else {
        // If n is odd, return x * halfPower * halfPower
        return x * halfPower * halfPower;
    }
}

// Example usage:
console.log(power(2, 10)); // Output: 1024
console.log(power(2, -2)); // Output: 0.25
console.log(power(3, 0));  // Output: 1
Complexity Analysis
Time Complexity
The time complexity of this approach is O(log n):

Each recursive call reduces 
ğ‘›
n by half, so the number of recursive calls is proportional to 
log
â¡
ğ‘›
logn.
This is much faster than a straightforward approach that would take O(n) time.
Space Complexity
The space complexity is O(log n) due to the recursive call stack:

The maximum depth of recursion corresponds to the number of times 
ğ‘›
n can be halved, which is 
log
â¡
ğ‘›
logn.
Proof of Correctness
Case 1: 
ğ‘›
=
0
n=0: By definition, any number raised to the power of 0 is 1, so power(x, 0) correctly returns 1.
Case 2: 
ğ‘›
>
0
n>0:
For even 
ğ‘›
n, 
ğ‘¥
ğ‘›
=
(
ğ‘¥
ğ‘›
/
2
)
2
x 
n
 =(x 
n/2
 ) 
2
 , which is accurately handled by the recursive call structure.
For odd 
ğ‘›
n, 
ğ‘¥
ğ‘›
=
ğ‘¥
Ã—
(
ğ‘¥
(
ğ‘›
âˆ’
1
)
/
2
)
2
x 
n
 =xÃ—(x 
(nâˆ’1)/2
 ) 
2
 , which is similarly handled.
Case 3: 
ğ‘›
<
0
n<0: The function calculates 
ğ‘¥
âˆ’
ğ‘›
=
1
ğ‘¥
ğ‘›
x 
âˆ’n
 = 
x 
n
 
1
â€‹
  correctly by calling itself with -n.
Advantages
Efficient for large values of 
ğ‘›
n due to the logarithmic time complexity.
Handles both positive and negative powers in a unified manner.
Disadvantages
Recursive Approach: May lead to stack overflow if 
ğ‘›
n is extremely large and the recursion limit is reached (though this is rare).
Alternative Approach (Iterative)
An iterative approach can also be used to avoid the recursion depth limitation. This uses the same principles of exponentiation by squaring in a loop.

javascript
Copy code
function powerIterative(x, n) {
    if (n === 0) return 1;
    let result = 1;
    let absN = Math.abs(n);

    while (absN > 0) {
        if (absN % 2 === 1) { // If n is odd, multiply result by x
            result *= x;
        }
        x *= x;             // Square the base
        absN = Math.floor(absN / 2);
    }

    return n > 0 ? result : 1 / result;
}

// Example usage:
console.log(powerIterative(2, 10)); // Output: 1024
console.log(powerIterative(2, -2)); // Output: 0.25
console.log(powerIterative(3, 0));  // Output: 1
Comparison of Iterative and Recursive Approaches
Iterative: Avoids recursion depth limitations and has the same O(log n) time complexity.
Recursive: May be more concise but can risk stack overflow for very large 
ğ‘›
n.
