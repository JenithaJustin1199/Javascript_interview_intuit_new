
To solve the Number of Good Pairs problem efficiently, we need to count pairs of indices 
(
ğ‘–
,
ğ‘—
)
(i,j) where nums[i] == nums[j] and 
ğ‘–
<
ğ‘—
i<j.

Optimized Approach
Use a Frequency Map: Instead of comparing each pair (which would have a time complexity of 
ğ‘‚
(
ğ‘›
2
)
O(n 
2
 )), we can use a hash map to store the frequency of each number as we iterate through nums.
Count Good Pairs with Combinatorics:
For each occurrence count 
ğ‘“
f of a number, we can form 
ğ‘“
Ã—
(
ğ‘“
âˆ’
1
)
2
2
fÃ—(fâˆ’1)
â€‹
  good pairs (this is derived from the combination formula 
ğ¶
(
ğ‘“
,
2
)
=
ğ‘“
!
2
!
Ã—
(
ğ‘“
âˆ’
2
)
!
C(f,2)= 
2!Ã—(fâˆ’2)!
f!
â€‹
 ).
Sum the Counts: Sum up the good pairs formed for each unique number.
Code
Here's the JavaScript code implementing this approach:

javascript
Copy code
function numIdenticalPairs(nums) {
    const freqMap = {};
    let count = 0;
    
    for (const num of nums) {
        if (freqMap[num]) {
            count += freqMap[num];
            freqMap[num]++;
        } else {
            freqMap[num] = 1;
        }
    }
    
    return count;
}

// Example usage:
console.log(numIdenticalPairs([1, 2, 3, 1, 1, 3])); // Output: 4
console.log(numIdenticalPairs([1, 1, 1, 1])); // Output: 6
console.log(numIdenticalPairs([1, 2, 3])); // Output: 0
Explanation with Example
For nums = [1,2,3,1,1,3]:

As we iterate, we build up freqMap as follows:
1 is seen 3 times, contributing 
3
Ã—
(
3
âˆ’
1
)
/
2
=
3
3Ã—(3âˆ’1)/2=3 pairs.
3 is seen 2 times, contributing 
2
Ã—
(
2
âˆ’
1
)
/
2
=
1
2Ã—(2âˆ’1)/2=1 pair.
Total count = 
3
+
1
=
4
3+1=4.
Complexity Analysis
Time Complexity: 
ğ‘‚
(
ğ‘›
)
O(n), where 
ğ‘›
n is the length of nums, because we go through the list once.
Space Complexity: 
ğ‘‚
(
ğ‘›
)
O(n), for storing the frequency map.
This approach is efficient and takes advantage of counting frequencies to avoid redundant comparisons.
