"I use Media Source Extensions to stream video in small chunks,
maintain a 15â€“30s buffer, 
and apply adaptive bitrate logic based on network and buffer health. 
Intersection Observer pauses off-screen videos to save CPU,
and uploads are handled via resumable chunked uploads with Service Worker support."
1ï¸âƒ£ ABR (Adaptive Bitrate Streaming)

**1-liner:** Auto-switch video quality in real time based on network + buffer + device.

**Why:**
* Unstable networks
* Faster start
* Lower data + CPU
**Common Formats:**
* HLS (`.m3u8`)
* DASH (`.mpd`)
User Network â‡„ Player â‡„ Manifest â‡„ Segments

2ï¸âƒ£ Multi-Resolution Encoding (Backend context â€“ interviewer expects awareness)

Same video encoded into multiple bitrates:

| Res   | Bitrate |
| ----- | ------- |
| 240p  | 300kbps |
| 360p  | 700kbps |
| 720p  | 2.5Mbps |
| 1080p | 5Mbps   |

Each â†’ split into **segments**

3ï¸âƒ£ Chunks / Segments
Small time-based video pieces (2â€“6s) fetched independently.
Why chunks?**
* Resume playback
* ABR switching
* Faster start
Video
 â”œâ”€ seg_0 (0â€“5s)
 â”œâ”€ seg_1 (5â€“10s)
 â”œâ”€ seg_2 (10â€“15s)
```
4ï¸âƒ£ Why `<video>` Alone Is Not Enough

Limitations:

* No ABR control
* No buffer insight
* No quality switching logic

ğŸ‘‰ Use **MSE (Media Source Extensions)**
5ï¸âƒ£ MSE (Media Source Extensions)

**1-liner:** JS-controlled video streaming into `<video>` buffer.

```
Fetch â†’ JS â†’ SourceBuffer â†’ <video>
```

Core Objects:

* `MediaSource`
* `SourceBuffer`

---

## 6ï¸âƒ£ SourceBuffer

**Role:** Holds binary video data for decoding.

```
mediaSource
 â”œâ”€ video SourceBuffer
 â””â”€ audio SourceBuffer
```

Operations:

* `appendBuffer()` â†’ add chunk
* `remove()` â†’ free memory

---

## 7ï¸âƒ£ Buffer Management (CRITICAL)

**Target:** 15â€“30s buffer

**Why:**

* <10s â†’ rebuffering
* > 30s â†’ memory waste

**Logic:**

```
if buffer < 10s â†’ fetch
if buffer > 30s â†’ cleanup
```

```
| Played | Buffered | Future |
```

---

## 8ï¸âƒ£ ABR Decision Engine (Frontend)

**Signals Used:**

* Chunk download time
* Buffer length
* Dropped frames
* Viewport size

**Sticky Rule:**

```
Slow download â†’ downgrade
Healthy buffer â†’ upgrade
```

```
Network â†“ â†’ Quality â†“
Network â†‘ â†’ Quality â†‘
```

---

## 9ï¸âƒ£ Intersection Observer (Feed Optimization)

**1-liner:** Detects visibility to pause/mute videos off-screen.

```
Viewport
 â”œâ”€ Video visible â†’ play
 â””â”€ Video hidden â†’ pause
```

**Why interviewers love this:**

* CPU optimization
* Battery saving
* Scales feeds

---

## ğŸ”Ÿ Thumbnail Loading

### A. Sprite Sheets (YouTube-style)

```
[ frame1 | frame2 | frame3 ]
```

* Single image
* CSS `background-position`

### B. Lazy-loaded thumbnails

* `loading="lazy"`

### C. Hover preview video

* 3â€“5s muted MP4/WebM

---

## 1ï¸âƒ£1ï¸âƒ£ Slow Network Handling

**APIs / Techniques:**

* `navigator.connection.effectiveType`
* Start low-quality
* Smaller buffer

```
2G â†’ 240p
4G â†’ 720p
```

Abort slow fetches:

* `AbortController`

---

## 1ï¸âƒ£2ï¸âƒ£ Resumable Uploads (Upload Side)
Large uploads split into chunks so failures can resume.

```
1GB File
 â”œâ”€ 5MB chunk 1
 â”œâ”€ 5MB chunk 2
 â””â”€ ...
```

---

## 1ï¸âƒ£3ï¸âƒ£ File API (Chunking)
```
file.slice(start, end)
```

Used to:
* Retry failed chunks
* Parallel uploads

---

## 1ï¸âƒ£4ï¸âƒ£ TUS Protocol (Industry Standard)
**Features:**

* Resume upload
* Checkpoints
* Idempotent chunks
Used by:

* Vimeo
* Cloudflare

---

## 1ï¸âƒ£5ï¸âƒ£ Service Worker (Bonus Points)
**Role:**
* Background retries
* Offline resume
* Upload persistence
```
Network â†“
Service Worker â†‘

 1ï¸âƒ£6ï¸âƒ£ Full Frontend Architecture (Sticky Diagram)

```
UI
 â”œâ”€ <video>
 â”œâ”€ Thumbnails
 â”œâ”€ IO

Playback Engine
 â”œâ”€ MSE
 â”œâ”€ SourceBuffer
 â”œâ”€ Buffer Manager
 â”œâ”€ ABR Logic

Network
 â”œâ”€ Chunk Fetcher
 â”œâ”€ Retry / Abort

Upload
 â”œâ”€ File Slice
 â”œâ”€ TUS
 â”œâ”€ SW
```
