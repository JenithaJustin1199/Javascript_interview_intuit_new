## 2Ô∏è‚É£ Requirements

### Functional Requirements (Short Notes)

* Users should be able to play videos seamlessly
* Video quality should adapt automatically based on network conditions
* Videos in a scrolling feed should pause when off-screen
* Thumbnails should load efficiently and preview quickly
* Users should be able to upload large video files reliably
* Uploads should resume after network failures or tab refresh

### Non-Functional Requirements (Short Notes)

* Fast startup time (low time-to-first-frame)
* Minimal buffering and rebuffering
* Low CPU and battery consumption
* Memory-efficient buffering
* Scales to millions of users
* Works on slow and unstable networks

---

## 3Ô∏è‚É£ High-Level Architecture (Frontend Perspective)

```
Browser (UI Layer)
 ‚îú‚îÄ Video Element (<video>)          # Native HTML media renderer
 ‚îú‚îÄ Feed Components                  # Cards, thumbnails, hover previews
 ‚îú‚îÄ Intersection Observer            # Visibility detection for videos
 ‚îú‚îÄ User Interaction Layer           # Play, pause, seek, scrub

Playback Engine (JavaScript)
 ‚îú‚îÄ Media Source Extensions           # Programmatic video buffering
 ‚îú‚îÄ Source Buffers                   # Audio and video buffers
 ‚îú‚îÄ Buffer Manager                   # Maintains healthy buffer window
 ‚îú‚îÄ Adaptive Bitrate Engine           # Chooses video quality dynamically

Network Layer
 ‚îú‚îÄ Manifest Fetcher                 # Fetches playlist information
 ‚îú‚îÄ Segment Fetcher                  # Downloads video chunks
 ‚îú‚îÄ Retry and Abort Logic             # Handles slow or failed requests

Upload Engine
 ‚îú‚îÄ File API Chunking                # Splits large files into chunks
 ‚îú‚îÄ Resumable Upload Protocol         # Resume-safe uploads
 ‚îú‚îÄ Service Worker                   # Background retry and persistence
```

Each block above is **frontend-owned or frontend-controlled**, which is why interviewers expect strong clarity here.

---

## 4Ô∏è‚É£ Index: Frontend Streaming Pipeline (One-Liners)

This index itself should give a **rough execution flow**.

1. Adaptive Bitrate Streaming ‚Äì Automatically switch video quality based on network and buffer health
2. Multi-Resolution Video Encoding ‚Äì Backend-prepared variants consumed by frontend logic
3. Video Segmentation ‚Äì Small time-based chunks for fast loading and switching
4. Limitations of Native Video Element ‚Äì Why JavaScript-level control is required
5. Media Source Extensions ‚Äì JavaScript-driven media buffering
6. Source Buffer Management ‚Äì Managing audio and video binary data
7. Buffer Window Strategy ‚Äì Maintaining an optimal buffered duration
8. Adaptive Bitrate Decision Engine ‚Äì Frontend quality selection logic
9. Visibility-Based Playback Control ‚Äì Pausing off-screen videos
10. Thumbnail and Preview Optimization ‚Äì Reducing perceived load time
11. Slow Network Detection and Handling ‚Äì Graceful degradation strategies
12. Resumable Chunked Uploads ‚Äì Reliable large file uploads
13. File API Chunking ‚Äì Low-level file slicing
14. Industry Upload Protocols ‚Äì Standardized resumable uploads
15. Service Worker Integration ‚Äì Offline and background reliability

---

## 5Ô∏è‚É£ Adaptive Bitrate Streaming

**Definition:** Automatically adjusts video quality in real time based on network conditions, buffer health, and device capability.

**Why it exists:**

* Networks fluctuate constantly
* Users scroll quickly through feeds
* Devices have different decoding capabilities

**Trade-offs:**

* Better experience vs increased logic complexity
* Requires accurate buffer and network metrics

**Alternatives:**

* Fixed-quality video (simpler, but poor user experience)
* Server-driven quality selection (less responsive than frontend logic)

---

## 6Ô∏è‚É£ Multi-Resolution Video Encoding (Awareness Topic)

**What it is:**

The same video is pre-encoded at multiple resolutions and bitrates on the backend.

Example:

* 240p ‚Äì low bandwidth
* 360p ‚Äì medium bandwidth
* 720p ‚Äì high bandwidth
* 1080p ‚Äì very high bandwidth

**Frontend role:**

* Selects which version to fetch
* Switches between them seamlessly

**Why interviewers expect this:**

Frontend engineers must understand how backend preparation enables frontend adaptability.

---

## 7Ô∏è‚É£ Video Segments (Chunks)

**Definition:** Small time-based pieces of a video, typically two to six seconds long.

**Why segmentation matters:**

* Faster initial playback
* Allows mid-playback quality switching
* Enables retrying only failed portions

**Trade-offs:**

* Smaller segments increase request count
* Larger segments increase startup delay

---

## 8Ô∏è‚É£ Why the Native Video Element Is Not Enough

**Limitations:**

* No insight into buffer health
* No manual quality switching
* No custom retry or prefetch logic

**Conclusion:**

To build production-grade streaming, we must control buffering through JavaScript.

---

## 9Ô∏è‚É£ Media Source Extensions

**Definition:** A browser Application Programming Interface that allows JavaScript to feed media data directly into a video element.

**Mental model:**

```
Network Fetch ‚Üí JavaScript ‚Üí Media Source ‚Üí Video Element
```

**Why it is powerful:**

* Full control over buffering
* Enables custom adaptive bitrate logic
* Decouples network from playback

**Alternatives:**

* Native streaming without control
* Third-party players built on top of this same interface

---

## üîü Source Buffers

**What they are:**

Binary containers that hold encoded audio and video data for decoding.

**Responsibilities:**

* Append new video chunks
* Remove old buffered data
* Prevent memory overflow

**Trade-offs:**

* Aggressive cleanup may cause rebuffering
* Large buffers waste memory

---

## 1Ô∏è‚É£1Ô∏è‚É£ Buffer Management Strategy

**Target window:** Approximately fifteen to thirty seconds of buffered content.

**Why:**

* Less than ten seconds causes frequent buffering
* More than thirty seconds wastes memory and delays quality switching

**Simple logic:**

* Fetch more when buffer is low
* Remove old data when buffer is too large

---

## 1Ô∏è‚É£2Ô∏è‚É£ Adaptive Bitrate Decision Engine

**Signals used:**

* Time taken to download recent segments
* Current buffered duration
* Dropped video frames
* Screen and viewport size

**Core rule:**

* Slow downloads trigger quality downgrade
* Stable buffer allows gradual upgrade

**Trade-offs:**

* Aggressive switching causes visible quality jumps
* Conservative switching may underutilize bandwidth

---

## 1Ô∏è‚É£3Ô∏è‚É£ Visibility-Based Playback Control

**Definition:** Automatically pause or mute videos when they leave the viewport.

**How it works:**

The Intersection Observer Application Programming Interface detects whether a video element is visible on screen.

**Why it matters:**

* Saves Central Processing Unit cycles
* Reduces battery drain
* Scales infinite scrolling feeds

**Alternative:**

* Scroll event listeners (less efficient and harder to optimize)

---

## 1Ô∏è‚É£4Ô∏è‚É£ Thumbnail and Preview Optimization

**Techniques:**

* Image sprite sheets for preview frames
* Lazy loading of images
* Short muted preview videos on hover

**Why:**

* Reduces perceived loading time
* Improves engagement without autoplaying full videos

---

## 1Ô∏è‚É£5Ô∏è‚É£ Slow Network Handling

**Detection methods:**

* Browser network information hints
* Segment download performance

**Strategies:**

* Start playback at low quality
* Reduce buffer size
* Abort slow network requests

**Trade-offs:**

* Conservative behavior improves reliability
* May reduce peak quality

---

## 1Ô∏è‚É£6Ô∏è‚É£ Resumable Chunked Uploads

**Definition:** Large files are split into small chunks so uploads can resume after failure.

**Why it is critical:**

* Mobile networks are unreliable
* Large uploads frequently fail mid-way

---

## 1Ô∏è‚É£7Ô∏è‚É£ File Application Programming Interface Chunking

**What it does:**

Allows slicing a file into byte ranges for upload.

**Benefits:**

* Retry individual chunks
* Parallelize uploads

---

## 1Ô∏è‚É£8Ô∏è‚É£ Resumable Upload Protocols

**What they provide:**

* Upload checkpoints
* Idempotent chunk handling
* Server-client agreement on progress

**Why frontend engineers care:**

* Simplifies retry logic
* Improves reliability guarantees

---

## 1Ô∏è‚É£9Ô∏è‚É£ Service Worker Integration

**What it is:**

A background JavaScript worker that runs independently of the page lifecycle.

**Frontend benefits:**

* Retry uploads when network returns
* Persist upload state across refresh
* Enable offline-first behavior

---

## 2Ô∏è‚É£0Ô∏è‚É£ Final Frontend Mental Model

```
User Interface
 ‚îú‚îÄ Video Element
 ‚îú‚îÄ Feed Cards
 ‚îú‚îÄ Thumbnails
 ‚îú‚îÄ Visibility Detection

Playback Engine
 ‚îú‚îÄ Media Source Extensions
 ‚îú‚îÄ Source Buffers
 ‚îú‚îÄ Buffer Manager
 ‚îú‚îÄ Adaptive Bitrate Logic

Network and Reliability
 ‚îú‚îÄ Segment Fetching
 ‚îú‚îÄ Abort and Retry

Upload Reliability
 ‚îú‚îÄ File Chunking
 ‚îú‚îÄ Resumable Uploads
 ‚îú‚îÄ Service Worker
```

This structure is **exactly how interviewers evaluate frontend system design maturity**.

---

If you want, next we can:

* Convert this into **one-page interview revision notes**
* Add **analytics dashboard parallel example** (heatmaps, charts, rendering strategy)
* Simulate **interviewer follow-up questions and answers**
