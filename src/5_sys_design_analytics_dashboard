## 2.1 Functional Requirements

* Show real-time user sign-up count (global + per region)
* Show geographic distribution using maps and heatmaps
* Show time-based trends (minute, hour, day)
* Auto-update dashboard without manual refresh
* Support filtering (region, time range, platform)
* Graceful degradation on slow or unstable networks

## 2.2 Non-Functional Requirements

* Fast First Contentful Paint (initial screen must load quickly)
* Smooth real-time updates without UI jank
* Scalable to millions of events per minute
* Accessible (keyboard navigation, screen readers)
* Fault-tolerant to partial data failures

---

# 3. High-Level Architecture Diagram (Front-End Centric)

+------------------------+
|        Browser         |
|------------------------|
| UI Components          |
| State Store            |
| Event Stream Listener  |  <- EventSource (SSE)
| Rendering Pipeline     |
+-----------+------------+
            |
            | HTTP (REST + SSE)
            v
+------------------------+
| CDN / Edge Layer       |
|------------------------|
| Static Assets          |
| REST Caching           |
+-----------+------------+
            |
            v
+------------------------+
| Analytics Aggregation  |
| API + Event Stream     |
+------------------------+
1. Initial Load (REST)

Exactly the same as before.

{
  "generatedAt": 1734355200000,
  "totals": { "global": 18234567 },
  "timeSeries": [...],
  "geo": [...]
}


This snapshot:

Is cached

Renders immediately

Hydrates the UI

2. Real-Time Updates (Server-Sent Events)
event: signup_delta
data: {
  "timestamp": 1734355212000,
  "delta": {
    "global": 15,
    "h3": [
      { "h3Index": "8928308280fffff", "delta": 3 }
    ]
  }
}

# 4. UI Screens – What the User Sees First

## 4.1 First Screen (Critical Rendering Path)

* Header with total sign-ups counter
* World map with heat intensity
* Skeleton loaders (not spinners)

**Why skeleton loaders?**
Skeletons preserve layout stability and reduce perceived loading time compared to spinners.

---

# 5. Index – Front-End Design Steps (High-Level Roadmap)

1. Rendering Strategy Selection
2. Data Fetching and Streaming Model
3. State Management Strategy
4. UI Component Breakdown
5. Map and Heatmap Visualization
6. Performance Optimizations
7. Network Failure and Backpressure Handling
8. Accessibility and Usability
9. Observability and Debuggability

By reading this index alone, an interviewer should understand how the system unfolds.

---

# 6. Step-by-Step Deep Dive

---

## 6.1 Rendering Strategy Selection

**One-liner:** Decide how the first screen HTML is generated.

### Options

### Option 1: Server-Side Rendering

* HTML is generated on the server and sent to the browser
* Faster first contentful paint

**Trade-offs:**

* Higher server cost
* Complexity in hydration

### Option 2: Client-Side Rendering (Chosen)

* Initial static shell from CDN
* Data fetched after page load

**Why chosen here?**

* Dashboard users tolerate a short delay
* Easier real-time updates
* Better caching at CDN

**Optimization:**

* Pre-render shell using static generation

---

## 6.2 Data Fetching and Streaming Model

**One-liner:** How data flows from server to UI.

### Initial Load

* Fetch aggregated metrics via REST APIs

### Real-Time Updates

* WebSocket connection for incremental updates

**What is WebSocket?**
WebSocket is a persistent connection allowing the server to push data to the browser without repeated requests.

**Trade-offs:**

* More complex connection handling
* Requires reconnection logic

**Alternative:**

* Server-Sent Events (simpler but one-directional)

---

## 6.3 State Management Strategy

**One-liner:** Where and how dashboard data lives in memory.

### Approach

* Centralized state store
* Separate static data and streaming data

**Why separation matters?**

* Prevents full re-render on every real-time tick

**Optimizations:**

* Batched updates
* Immutable updates for predictability

---

## 6.4 UI Component Breakdown

**One-liner:** Break UI into predictable, isolated parts.

### Core Components

* Summary Counter Component
* Time Series Chart Component
* Map Container Component
* Filters Panel Component

**Best Practice:**

* Dumb components for rendering
* Smart components for data wiring

---

## 6.5 Map and Heatmap Visualization

**One-liner:** Visualize geographic density efficiently.

### Heatmap

**What is a Heatmap?**
A heatmap visually represents data density using color intensity, commonly used to show concentrations over geography.

### H3 Indexing

**What is H3?**
H3 is a hexagonal hierarchical geospatial indexing system developed by Uber that divides the world into hexagonal cells.

**Why hexagons?**

* Uniform adjacency
* Better aggregation than squares

### Rendering Strategy

* Pre-aggregated H3 cells from backend
* Render using Canvas or WebGL

**What is WebGL?**
WebGL is a browser technology that uses the Graphics Processing Unit to render complex graphics efficiently.

**Trade-offs:**

* Canvas: simpler, lower performance
* WebGL: complex, high performance

---

## 6.6 Performance Optimizations

**One-liner:** Keep the UI smooth under heavy data load.

### Techniques

* Virtualized lists for tables
* Memoized chart components
* Offscreen canvas rendering
* Throttled real-time updates

**Why throttling?**
Updating the UI on every incoming event causes main-thread congestion, layout recalculation, and dropped animation frames. Throttling batches updates into predictable intervals (for example, every 500 milliseconds), keeping frames per second stable.

---

## 6.6.1 Data Shape From Backend (Very Important for Front-End)

**One-liner:** Backend sends *render-ready, aggregated data*, not raw events.

### Initial Load API Response (REST)

```json
{
  "generatedAt": 1734355200000,
  "timeWindow": "last_24_hours",
  "totals": {
    "global": 18234567,
    "byPlatform": {
      "web": 8234567,
      "android": 6234567,
      "ios": 3765433
    }
  },
  "timeSeries": [
    { "timestamp": 1734351600000, "count": 1245 },
    { "timestamp": 1734351900000, "count": 1312 }
  ],
  "geo": [
    { "h3Index": "8928308280fffff", "count": 340 },
    { "h3Index": "8928308280bffff", "count": 120 }
  ]
}
```

**Why this shape?**

* Time series maps directly to charts
* H3 cells map directly to heatmap rendering
* No transformation-heavy work on the browser

---

### Real-Time Stream Payload (WebSocket)

```json
{
  "type": "incremental_update",
  "timestamp": 1734355212000,
  "delta": {
    "global": 12,
    "h3": [
      { "h3Index": "8928308280fffff", "delta": 2 }
    ]
  }
}
```

**Key Idea:**

* Backend sends *deltas*, not full snapshots
* Front-end applies deltas to cached state

---

## 6.6.2 Front-End Caching Strategy

**One-liner:** Cache aggressively, but invalidate intentionally.

### Where Data Is Stored

1. **In-memory cache (JavaScript runtime)**

   * Holds latest dashboard state
   * Fastest access, resets on refresh

2. **Persistent cache (Browser storage)**

   * Used only for initial hydration
   * Example: last successful snapshot

---

### Cache Layers Explained

#### In-Memory State Cache

* Central state store holds:

  * Last full snapshot
  * Rolling time-series window
  * H3 cell aggregates

**Why in-memory?**

* Charts re-render frequently
* Storage access would be too slow

---

#### Persistent Cache (Local Storage or Indexed Database)

**What is Indexed Database?**
Indexed Database is a browser-native database for storing structured data asynchronously.

**Stored Data:**

* Last REST snapshot
* Metadata like timestamp and version

**Usage Pattern:**

* Load cached snapshot immediately
* Render UI instantly
* Replace with fresh data when network responds

**Trade-off:**

* Slightly stale data is acceptable for analytics

---

## 6.6.3 Cache Invalidation Rules

**One-liner:** Never cache forever.

### Rules

* Snapshot expires after fixed time window
* Version mismatch invalidates cache
* Manual refresh clears cache

**Why versioning?**
Backend data contracts change over time; versioning avoids runtime crashes.

---

---

## 6.7 Network Failure and Backpressure Handling

**One-liner:** Prevent UI collapse on slow or noisy networks.

### Strategies

* Drop intermediate updates, keep latest state
* Show stale data indicator
* Exponential retry with jitter

**What is Backpressure?**
Backpressure is controlling data flow when the consumer cannot keep up with the producer.

---

## 6.8 Accessibility and Usability

**One-liner:** Ensure the dashboard works for everyone.

### Practices

* Keyboard navigable filters
* Screen-reader friendly charts
* Color-blind safe palettes

---

## 6.9 Observability and Debuggability

**One-liner:** Make issues visible in production.

### Front-End Metrics

* First contentful paint
* Long tasks
* WebSocket disconnect rate

**Tools:**

* Performance Observer
* Custom logging overlays

---

# 7. Summary for Interviewers

* Start with screen and rendering strategy
* Explain data flow clearly
* Emphasize performance and user perception
* Always discuss trade-offs
* Tie UI decisions back to scale and reliability

This approach signals **senior front-end system design maturity**.


