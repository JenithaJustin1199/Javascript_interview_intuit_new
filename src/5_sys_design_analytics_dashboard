

## 2.1 Functional Requirements

* Show real-time user sign-up count (global + per region)
* Show geographic distribution using maps and heatmaps
* Show time-based trends (minute, hour, day)
* Auto-update dashboard without manual refresh
* Support filtering (region, time range, platform)
* Graceful degradation on slow or unstable networks

## 2.2 Non-Functional Requirements

* Fast First Contentful Paint (initial screen must load quickly)
* Smooth real-time updates without UI jank
* Scalable to millions of events per minute
* Accessible (keyboard navigation, screen readers)
* Fault-tolerant to partial data failures

---

# 3. High-Level Architecture Diagram (Front-End Centric)

```
+----------------------+
|      User Browser    |
|----------------------|
| React / UI Layer     |  <- Renders charts, maps, counters
| State Management     |  <- Manages real-time + cached state
| Data Fetching Layer  |  <- Fetch, stream, retry, backpressure
| Rendering Optimizer  |  <- Virtualization, memoization
+----------+-----------+
           |
           | HTTPS / WebSocket
           v
+----------------------+
|   Edge / CDN Layer   |  <- Static assets, caching, SSR HTML
+----------+-----------+
           |
           v
+----------------------+
| Analytics APIs       |  <- Aggregated sign-up metrics
+----------------------+
```

**Note:** Backend complexity is hidden from the front-end using aggregated APIs and streaming endpoints.

---

# 4. UI Screens – What the User Sees First

## 4.1 First Screen (Critical Rendering Path)

* Header with total sign-ups counter
* World map with heat intensity
* Skeleton loaders (not spinners)

**Why skeleton loaders?**
Skeletons preserve layout stability and reduce perceived loading time compared to spinners.

---

# 5. Index – Front-End Design Steps (High-Level Roadmap)

1. Rendering Strategy Selection
2. Data Fetching and Streaming Model
3. State Management Strategy
4. UI Component Breakdown
5. Map and Heatmap Visualization
6. Performance Optimizations
7. Network Failure and Backpressure Handling
8. Accessibility and Usability
9. Observability and Debuggability

By reading this index alone, an interviewer should understand how the system unfolds.

---

# 6. Step-by-Step Deep Dive

---

## 6.1 Rendering Strategy Selection

**One-liner:** Decide how the first screen HTML is generated.

### Options

### Option 1: Server-Side Rendering

* HTML is generated on the server and sent to the browser
* Faster first contentful paint

**Trade-offs:**

* Higher server cost
* Complexity in hydration

### Option 2: Client-Side Rendering (Chosen)

* Initial static shell from CDN
* Data fetched after page load

**Why chosen here?**

* Dashboard users tolerate a short delay
* Easier real-time updates
* Better caching at CDN

**Optimization:**

* Pre-render shell using static generation

---

## 6.2 Data Fetching and Streaming Model

**One-liner:** How data flows from server to UI.

### Initial Load

* Fetch aggregated metrics via REST APIs

### Real-Time Updates

* WebSocket connection for incremental updates

**What is WebSocket?**
WebSocket is a persistent connection allowing the server to push data to the browser without repeated requests.

**Trade-offs:**

* More complex connection handling
* Requires reconnection logic

**Alternative:**

* Server-Sent Events (simpler but one-directional)

---

## 6.3 State Management Strategy

**One-liner:** Where and how dashboard data lives in memory.

### Approach

* Centralized state store
* Separate static data and streaming data

**Why separation matters?**

* Prevents full re-render on every real-time tick

**Optimizations:**

* Batched updates
* Immutable updates for predictability

---

## 6.4 UI Component Breakdown

**One-liner:** Break UI into predictable, isolated parts.

### Core Components

* Summary Counter Component
* Time Series Chart Component
* Map Container Component
* Filters Panel Component

**Best Practice:**

* Dumb components for rendering
* Smart components for data wiring

---

## 6.5 Map and Heatmap Visualization

**One-liner:** Visualize geographic density efficiently.

### Heatmap

**What is a Heatmap?**
A heatmap visually represents data density using color intensity, commonly used to show concentrations over geography.

### H3 Indexing

**What is H3?**
H3 is a hexagonal hierarchical geospatial indexing system developed by Uber that divides the world into hexagonal cells.

**Why hexagons?**

* Uniform adjacency
* Better aggregation than squares

### Rendering Strategy

* Pre-aggregated H3 cells from backend
* Render using Canvas or WebGL

**What is WebGL?**
WebGL is a browser technology that uses the Graphics Processing Unit to render complex graphics efficiently.

**Trade-offs:**

* Canvas: simpler, lower performance
* WebGL: complex, high performance

---

## 6.6 Performance Optimizations

**One-liner:** Keep the UI smooth under heavy data load.

### Techniques

* Virtualized lists for tables
* Memoized chart components
* Offscreen canvas rendering
* Throttled real-time updates

**Why throttling?**
Updating the UI on every event causes frame drops.

---

## 6.7 Network Failure and Backpressure Handling

**One-liner:** Prevent UI collapse on slow or noisy networks.

### Strategies

* Drop intermediate updates, keep latest state
* Show stale data indicator
* Exponential retry with jitter

**What is Backpressure?**
Backpressure is controlling data flow when the consumer cannot keep up with the producer.

---

## 6.8 Accessibility and Usability

**One-liner:** Ensure the dashboard works for everyone.

### Practices

* Keyboard navigable filters
* Screen-reader friendly charts
* Color-blind safe palettes

---

## 6.9 Observability and Debuggability

**One-liner:** Make issues visible in production.

### Front-End Metrics

* First contentful paint
* Long tasks
* WebSocket disconnect rate

**Tools:**

* Performance Observer
* Custom logging overlays

---

# 7. Summary for Interviewers

* Start with screen and rendering strategy
* Explain data flow clearly
* Emphasize performance and user perception
* Always discuss trade-offs
* Tie UI decisions back to scale and reliability

This approach signals **senior front-end system design maturity**.
