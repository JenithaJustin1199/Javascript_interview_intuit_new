 2Ô∏è‚É£ Requirements

### Functional Requirements (Short Notes)

* Messages must appear instantly on send
* Messages must be ordered correctly
* One-to-one and group conversations
* Presence indicators (online, typing)
* Read receipts based on visibility
* Support rich media messages
* Load chat history efficiently

### Non-Functional Requirements (Short Notes)

* Low perceived latency
* Strong correctness guarantees
* Works under flaky networks
* Smooth scrolling experience
* Scales to large message threads
* Memory- and CPU-efficient rendering

---

## 3Ô∏è‚É£ High-Level Frontend Architecture

```
User Interface Layer
 ‚îú‚îÄ Thread View                      # Message list rendering
 ‚îú‚îÄ Message Composer                 # Text, media input
 ‚îú‚îÄ Message Bubbles                  # Visual message units
 ‚îú‚îÄ Media Renderers                  # Image, video, voice

Viewport Controller
 ‚îú‚îÄ Scroll Manager                   # Sticky bottom, preserve scroll
 ‚îú‚îÄ Intersection Observer            # Visibility detection

State Layer
 ‚îú‚îÄ Message Store                    # Normalized message state
 ‚îú‚îÄ Conversation Store               # Conversation metadata
 ‚îú‚îÄ Presence Store                   # Online / typing status

Realtime Control Layer
 ‚îú‚îÄ Socket Manager                   # Single WebSocket connection
 ‚îú‚îÄ Optimistic Update Engine         # Pending ‚Üí sent ‚Üí failed
 ‚îú‚îÄ Concurrency Resolver             # Ordering and deduplication

Network Layer
 ‚îú‚îÄ WebSocket Channel                # Live messages and signals
 ‚îú‚îÄ REST APIs                        # History, pagination, previews
```

Each block above is **explicitly frontend-owned**, which is what interviewers evaluate in senior frontend rounds.

---

## 4Ô∏è‚É£ Index / Agenda (Execution Flow)

Reading this index alone should give a **clear mental model** of the system.

1. Problem Definition ‚Äì Real-time one-to-one and group messaging
2. Core Requirements ‚Äì Instant user experience and correctness
3. Transport Choice ‚Äì Why WebSocket is required
4. Connection Lifecycle ‚Äì Authentication, heartbeats, reconnection
5. Dual Stream Model ‚Äì History versus live messages
6. Race Conditions ‚Äì Ordering and deduplication
7. Optimistic User Interface ‚Äì Pending, sent, failed states
8. State Normalization ‚Äì Flat, scalable data structures
9. Socket Manager ‚Äì Single source of WebSocket truth
10. Message Store ‚Äì Centralized state management
11. Concurrency Resolver ‚Äì Conflict and ordering logic
12. Presence and Inference ‚Äì Online and typing signals
13. Read Receipts ‚Äì Visibility-based seen logic
14. Intersection Observer ‚Äì Efficient viewport detection
15. Rich Media Messages ‚Äì Images, video, voice, attachments
16. Uniform Resource Locator Unfurling ‚Äì Link previews
17. Message Bubble System ‚Äì Reusable visual components
18. Scrolling Model ‚Äì Sticky and preserved scroll behavior
19. Virtualization ‚Äì Rendering performance at scale
20. Failure Scenarios ‚Äì Network, retries, resynchronization
21. End Summary ‚Äì Why this design scales

---

## 5Ô∏è‚É£ Problem Definition

**One-liner:**

A real-time messaging system where messages appear instantly, stay correctly ordered, support rich content, and remain reliable under failure.

---

## 6Ô∏è‚É£ Core Requirements

* Messages should render before server acknowledgment
* Server remains the source of truth for ordering
* Presence information is independent of messages
* Read receipts depend on what the user actually sees
* Scroll behavior affects correctness, not just experience

---

## 7Ô∏è‚É£ Transport Choice: Why WebSocket

**Definition:**

WebSocket is a persistent, full-duplex communication protocol between browser and server.

**Why WebSocket is chosen:**

* Low-latency message delivery
* Server-initiated pushes
* Efficient for continuous updates

**Used for:**

* Live messages
* Presence updates
* Typing indicators
* Read receipt signals

**Alternative:**

* Long polling (higher latency, more overhead)

---

## 8Ô∏è‚É£ WebSocket Connection Lifecycle

**Lifecycle steps:**

* Connect when application loads
* Authenticate once per connection
* Maintain heartbeat to detect disconnects
* Reconnect automatically on failure

```
Client ‚Üí ping ‚Üí Server
Client ‚Üê pong ‚Üê Server
```

---

## 9Ô∏è‚É£ Fallback Strategy

**Problem:**

WebSocket connections can drop on unstable networks.

**Strategy:**

* Temporarily fall back to REST polling
* Resynchronize missed messages
* Retry WebSocket connection

```
WebSocket down ‚Üí REST sync ‚Üí WebSocket retry
```

---

## üîü Dual Stream Model (Critical Concept)

**Why it exists:**

* Chat history is finite and paginated
* Live messages are infinite and real-time

**Model:**

```
REST APIs ‚Üí Historical messages
WebSocket ‚Üí Live message stream
```

**Rule:**

* Load history first
* Append live messages after

---

## 1Ô∏è‚É£1Ô∏è‚É£ Race Conditions and Deduplication

**Problem:**

The same message may arrive from:

* WebSocket (live)
* REST API (history fetch)

**Solution:**

* Unique message identifiers
* Server-assigned timestamps
* Deduplication in the store

---

## 1Ô∏è‚É£2Ô∏è‚É£ Optimistic User Interface

**Definition:**

The user interface updates immediately before server confirmation.

**Flow:**

```
User sends message
‚Üí Message shown as pending
‚Üí Server acknowledgment
‚Üí Message marked as sent
‚Üí Failure marks message as failed
```

**States:**

* Pending
* Sent
* Failed

**Why interviewers care:**

This is a strong signal of senior frontend ownership.

---

## 1Ô∏è‚É£3Ô∏è‚É£ State Normalization

**Why normalization matters:**

* Avoids deep nested updates
* Enables efficient pagination
* Simplifies deduplication

**Example shape:**

```
conversations: { id ‚Üí metadata }
messages: { id ‚Üí message }
conversationMessages: { conversationId ‚Üí [messageIds] }
```

---

## 1Ô∏è‚É£4Ô∏è‚É£ Socket Manager

**Responsibilities:**

* Maintain a single WebSocket connection per tab
* Handle reconnects and heartbeats
* Dispatch events to the store

**Important rule:**

Never create multiple WebSocket connections from the same tab.

---

## 1Ô∏è‚É£5Ô∏è‚É£ Message Store

**Holds:**

* Messages
* Conversations
* Delivery status
* Presence information

**Receives updates from:**

* REST API responses
* WebSocket events
* Optimistic user actions

---

## 1Ô∏è‚É£6Ô∏è‚É£ Concurrency Resolver

**Purpose:**

Ensures correctness when messages arrive out of order.

**Handles:**

* Message ordering
* Duplicate events
* Late server acknowledgments

**Uses:**

* Temporary client identifiers
* Server-generated message identifiers
* Server timestamps

---

## 1Ô∏è‚É£7Ô∏è‚É£ Presence and Inference

**Presence states:**

* Online
* Offline
* Last seen

**Typing indicators:**

* Throttled WebSocket signals

**Key principle:**

Presence information is not message data.

---

## 1Ô∏è‚É£8Ô∏è‚É£ Read Receipts

**Definition:**

A message is marked as read only when it becomes visible to the user.

**How it works:**

* Track message visibility
* Emit read event when visible

**Tool used:**

Intersection Observer Application Programming Interface.

---

## 1Ô∏è‚É£9Ô∏è‚É£ Intersection Observer

**What it is:**

A browser interface that efficiently detects element visibility relative to the viewport.

**Used for:**

* Read receipts
* Lazy loading media
* Performance optimizations

**Why it is preferred:**

* No manual scroll listeners
* Highly efficient

---

## 2Ô∏è‚É£0Ô∏è‚É£ Rich Media Messages

**Supported types:**

* Text
* Images
* Video
* Voice notes
* Attachments

**Design principle:**

* Shared message bubble layout
* Type-specific renderers

---

## 2Ô∏è‚É£1Ô∏è‚É£ Uniform Resource Locator Unfurling

**Flow:**

```
User pastes link
‚Üí Frontend sends link to backend
‚Üí Backend fetches metadata
‚Üí Frontend renders preview card
```

**Frontend responsibilities:**

* Loading skeleton
* Error fallback

---

## 2Ô∏è‚É£2Ô∏è‚É£ Message Bubble System

**Responsibilities:**

* Content-aware sizing
* Accessibility support
* Consistent layout across message types

---

## 2Ô∏è‚É£3Ô∏è‚É£ Scrolling Model (Correctness-Critical)

**Problems addressed:**

* New messages arriving
* User reading older messages

**Rules:**

* Auto-scroll only if user is at bottom
* Preserve scroll position otherwise

```
User at bottom ‚Üí auto-scroll
User scrolling up ‚Üí preserve position
```

---

## 2Ô∏è‚É£4Ô∏è‚É£ Virtualization and Windowing

**Why needed:**

* Large conversations can contain thousands of messages

**Approach:**

* Render only visible messages
* Recycle message components

---

## 2Ô∏è‚É£5Ô∏è‚É£ Failure Scenarios

| Scenario             | Frontend Handling           |
| -------------------- | --------------------------- |
| WebSocket disconnect | Reconnect and resynchronize |
| Message send failure | Retry or show error state   |
| Duplicate messages   | Deduplicate by identifier   |
| Page refresh         | Restore store and resync    |

---

## 2Ô∏è‚É£6Ô∏è‚É£ End Summary (Interview-Ready)

**‚ÄúThis design separates message history from live streams, uses WebSocket for low-latency delivery, applies optimistic updates for instant user experience, and ensures correctness through normalization, ordering, and viewport-aware read receipts.‚Äù**

---

