

## 1ï¸âƒ£ Index / Agenda (One-liner Each)

1. **Problem Definition** â€“ Real-time collaborative document editor
2. **Interview Scope** â€“ What frontend owns vs backend
3. **Core Requirements** â€“ Reliability, order, offline, scale
4. **High-Level Architecture** â€“ Editor + collaboration engine
5. **Data Model** â€“ Operations, not raw text
6. **In-Order Delivery** â€“ Sequence-based application
7. **Collaboration Models** â€“ OT vs CRDT
8. **OT Basics** â€“ Transform concurrent edits
9. **Conflict Handling** â€“ Invisible to users
10. **Offline-First Design** â€“ Local-first edits
11. **Re-sync After Offline** â€“ Replay + transform
12. **Reliability Guarantees** â€“ ACK + retry
13. **Multi-user Scaling** â€“ Throttling + batching
14. **Cursor & Presence** â€“ Awareness channel
15. **Performance** â€“ Instant typing, async sync
16. **Rendering Strategy** â€“ Virtualized document
17. **Network Layer** â€“ WebSocket lifecycle
18. **Failure Scenarios** â€“ Recovery paths
19. **Security Awareness** â€“ Permissions + sanitization
20. **End Summary** â€“ Why this works at scale

---

## 2ï¸âƒ£ Frontend Architecture (Draw This)

```
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚     UI Editor       â”‚
                â”‚  (Text, Cursor,     â”‚
                â”‚   Selection, Tools) â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  Collaboration FE   â”‚
                â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
                â”‚ Operation Queue     â”‚
                â”‚ Version Tracker     â”‚
                â”‚ OT / CRDT Adapter   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   Network Layer     â”‚
                â”‚  (WebSocket, ACKs)  â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  Local Persistence  â”‚
                â”‚ (IndexedDB Ops Log) â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ Backend (Awareness) â”‚
                â”‚ Ordering + Fan-out â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3ï¸âƒ£ Interview Hints (What to Emphasize While Talking)

* Frontend **does not wait** for server to apply edits
* Operations are **local-first**
* OT/CRDT math is **not implemented in interview**
* Consistency is achieved via **ordering + transformation**
* Offline is **default mode**, not an edge case
* Cursor/presence is **separate from document state**
* Rendering is **incremental**, not full re-render
* Reliability comes from **ACK + replay**
* Users never see conflicts

---

## 4ï¸âƒ£ Sticky Notes (Topic-wise)

---

### 1. What Is Google Docs?

**1-liner**
A real-time collaborative editor where multiple users edit the same document with strong consistency, offline support, and low-latency typing.

---

### 2. Interview Scope (Senior FE)

âŒ Not expected:

* Distributed storage internals
* OT/CRDT proofs

âœ… Expected:

* Frontend collaboration flow
* Sync + offline strategy
* Performance & UX correctness

---

### 3. Core Requirements

* Reliability â†’ no data loss
* In-order edits â†’ correct sequence
* Multi-user â†’ 10â€“100 editors
* Offline â†’ edit without network
* Conflict handling â†’ auto-merge
* Performance â†’ instant typing

---

### 4. Data Model (Key Insight)

**Document = list of operations**

```
Insert("A", pos=5)
Delete(len=3, pos=8)
```

Why:

* Easier merge
* Smaller payloads
* Real-time friendly

---

### 5. In-Order Delivery (CRITICAL)

**Problem**

* Network messages arrive out of order

**Frontend Solution**

* Version numbers / sequence IDs
* Apply only expected version

```
Expected: 1 â†’ 2 â†’ 3
Arrives: 1, 3, 2
Apply: 1 â†’ 2 â†’ 3
```

---

### 6. Collaboration Models

| Model | Used By       |
| ----- | ------------- |
| OT    | Google Docs   |
| CRDT  | Figma, Notion |

Frontend supports either via adapter layer.

---

### 7. OT (Operational Transform)

**1-liner**
Transforms concurrent edits so all users converge to the same document while preserving intent.

Example:

```
User A: Insert "X" @5
User B: Insert "Y" @5
â†’ transform â†’ deterministic order
```

Frontend role:

* Apply transformed ops
* Keep cursor stable

---

### 8. Conflict Handling (User POV)

* Conflicts are invisible
* No manual merge
* No last-write-wins

```
Edit A + Edit B
â†’ transform
â†’ same document
```

---

### 9. Offline-First Design

**Golden Rule**

* User typing must never block on network

Flow:

```
User Edit
â†’ Apply locally
â†’ Queue operation
â†’ Sync later
```

Stored in:

* IndexedDB

---

### ğŸ”Ÿ Re-sync After Offline

Steps:

1. Fetch latest server version
2. Replay offline ops
3. Transform if needed

```
Server v10
Offline ops from v7
â†’ transform â†’ v11
```

---

### 1ï¸âƒ£1ï¸âƒ£ Reliability & Durability

Frontend guarantees:

* ACK-based delivery
* Retry unacked ops
* Persist ops locally

```
Send â†’ ACK â†’ Clear
No ACK â†’ Retry
```

---

### 1ï¸âƒ£2ï¸âƒ£ Multi-Participant Scaling

Problems:

* Too many cursor updates
* Too many ops per second

Solutions:

* Throttle cursor events
* Batch operations

```
Typing burst â†’ batch â†’ send
```

---

### 1ï¸âƒ£3ï¸âƒ£ Cursor & Presence (Senior Signal)

* Separate channel from document ops
* Ephemeral data

```
Presence â‰  Document State
```

Includes:

* Cursor position
* Selection
* User color

---

### 1ï¸âƒ£4ï¸âƒ£ Performance Rules (Typing)

* Local apply is synchronous
* Network is async

```
Keypress â†’ DOM update â†’ sync later
```

Optimizations:

* Piece table / rope
* Avoid full document re-render

---

### 1ï¸âƒ£5ï¸âƒ£ Rendering Strategy

* Large docs are virtualized
* Render visible blocks only
* Avoid `contenteditable` pitfalls

```
Huge Doc
â†’ Visible blocks only
```

---

### 1ï¸âƒ£6ï¸âƒ£ Network Layer

* WebSocket
* Heartbeats
* Reconnect logic

```
FE â‡„ WS â‡„ Server
```

---

### 1ï¸âƒ£7ï¸âƒ£ Failure Scenarios (Interview Gold)

| Failure   | Handling           |
| --------- | ------------------ |
| WS drop   | Reconnect + replay |
| Tab crash | Restore IndexedDB  |
| Conflict  | OT resolves        |

---

### 1ï¸âƒ£8ï¸âƒ£ Security (Awareness Only)

* Auth tokens
* Doc-level permissions
* Sanitized input

---

### 1ï¸âƒ£9ï¸âƒ£ Ending Statement (Memorize)

**â€œThis design enables real-time collaboration with instant local edits, offline safety, automatic conflict resolution, and scalable performance by modeling documents as operations and synchronizing them reliably.â€**

---

If you want next:

* **OT vs CRDT decision justification**
* **Whiteboard-only explanation**
* **React editor implementation hints**
* **LinkedIn-style follow-up questions**

Say the word.
