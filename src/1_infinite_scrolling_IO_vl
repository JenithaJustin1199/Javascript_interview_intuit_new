HTML:
<body>

  <h2>Virtualized Infinite Scroll</h2>

  <!-- WHY:
       Wrapper for virtualization + infinite scroll.
       Scroll events & IO are scoped to this container. -->
  <div id="scrollContainer">

    <!-- WHY:
         Spacer creates illusion of full list height.
         Scrollbar size depends on this element. -->
    <div id="spacer">

      <!-- WHY:
           Only visible rows live here.
           This node is moved using transform instead of layout properties. -->
      <div id="window"></div>
    </div>

    <!-- WHY:
         Sentinel element.
         IntersectionObserver watches this to decide WHEN to load more data. -->
    <div id="loading">Loading more itemsâ€¦</div>
  </div>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- WHY:
       Ensures correct text encoding.
       Prevents weird character rendering issues.
       Alternative (bad): Omitting charset can cause encoding bugs. -->

  <title>Virtualized Infinite List (IO + GPU)</title>

  <style>
    /* ===============================
       Global Page Styles
    =============================== */
    body {
      margin: 0;
      /* WHY:
         Remove default browser margin.
         Prevents unexpected scrollbars and layout shifts.
         Alternative: Leaving default margin causes UI inconsistency. */

      font-family: Arial, sans-serif;
      /* WHY:
         Simple, readable font for demo.
         Alternative: Default serif fonts look inconsistent across OS. */

      background: #f5f5f5;
      /* WHY:
         Visual contrast between page and scroll container.
         Helps debugging layout boundaries. */

      padding: 20px;
      /* WHY:
         Prevent content from sticking to screen edges.
         Improves readability. */
    }

    /* ===============================
       Scroll Container (Viewport)
    =============================== */
    #scrollContainer {
      height: 600px;
      /* WHY:
         Fixed viewport height is REQUIRED for virtualization math.
         Without fixed height â†’ cannot calculate visible rows.
         Alternative: Full page scroll makes virtualization harder. */

      overflow-y: auto;
      /* WHY:
         Enables native scrolling.
         Virtualization relies on scrollTop from this container.
         Alternative: overflow: visible â†’ no scrolling. */

      border: 1px solid #ccc;
      /* WHY:
         Visual boundary for demo clarity.
         Not required functionally. */

      background: #fff;
      /* WHY:
         Distinguish content from page background. */

      position: relative;
      /* WHY:
         Needed because children (spacer/window) use absolute positioning.
         Alternative: Without relative, absolute children position to body. */
    }

    /* ===============================
       Spacer (Fake Full Height)
    =============================== */
    #spacer {
      position: relative;
      /* WHY:
         Acts as a positioning context for the window.
         Represents total scrollable height.
         Alternative: No spacer â†’ scrollbar wonâ€™t reflect full dataset. */

      width: 100%;
    }

    /* ===============================
       Windowed Render Box
       (GPU Accelerated Layer)
    =============================== */
    #window {
      position: absolute;
      /* WHY:
         Allows free vertical movement via transform.
         Alternative: position: static â†’ transform breaks layout. */

      top: 0;
      left: 0;
      width: 100%;

      will-change: transform;
      /* WHY:
         Hints browser to promote this element to GPU layer.
         Improves smooth scrolling.
         Alternative: Without this, browser may repaint instead of composite. */
    }

    /* ===============================
       Individual Row
    =============================== */
    .row {
      height: 50px;
      /* WHY:
         Fixed height simplifies virtualization math.
         offset = index * height (O(1)).
         Alternative: Dynamic height â†’ needs measurement & caching. */

      line-height: 50px;
      /* WHY:
         Vertical centering without extra flexbox.
         Simple & performant. */

      padding: 0 16px;
      /* WHY:
         Horizontal spacing for readability. */

      box-sizing: border-box;
      /* WHY:
         Ensures padding does NOT increase row height.
         Critical for correct scroll calculations. */

      border-bottom: 1px solid #eee;
      /* WHY:
         Visual separation of rows.
         Not required for logic. */
    }

    /* ===============================
       Loading Sentinel
    =============================== */
    #loading {
      height: 60px;
      /* WHY:
         Needs physical height to be observed by IntersectionObserver.
         Zero height â†’ observer may never trigger. */

      display: flex;
      align-items: center;
      justify-content: center;
      /* WHY:
         Center loading text visually. */

      color: #666;
      font-size: 14px;
    }
  </style>
</head>



  <script>
    /* ===============================
       Configuration
    =============================== */
    const ROW_HEIGHT = 50;
    /* WHY:
       Used for index â†’ pixel calculation.
       Required for virtualization math.
       Alternative: Variable heights â†’ complex measurement logic. */

    const BUFFER = 5;
    /* WHY:
       Extra rows above & below viewport.
       Prevents blank gaps during fast scroll.
       Alternative: No buffer â†’ flickering. */

    const PAGE_SIZE = 50;
    /* WHY:
       Backend pagination simulation.
       Decouples data loading from rendering. */

    const MAX_ITEMS = 1000;
    /* WHY:
       Prevent infinite growth in demo.
       Simulates finite backend dataset. */

    /* ===============================
       State
    =============================== */
    let items = [];
    /* WHY:
       Holds fetched data.
       Virtualization limits DOM, NOT data size. */

    let isLoading = false;
    /* WHY:
       Prevents duplicate fetches.
       Alternative: Without this â†’ race conditions & duplicate items. */

    /* ===============================
       DOM References
    =============================== */
    const scrollContainer = document.getElementById("scrollContainer");
    const spacer = document.getElementById("spacer");
    const windowEl = document.getElementById("window");
    const loadingEl = document.getElementById("loading");

    /* ===============================
       Mock Fetch (Pagination)
    =============================== */
    function fetchMoreItems() {
      if (isLoading || items.length >= MAX_ITEMS) return;
      /* WHY:
         Guard against parallel fetches and over-fetching.
         Alternative: Multiple simultaneous requests â†’ duplicates. */

      isLoading = true;
      loadingEl.textContent = "Loading more itemsâ€¦";

      setTimeout(() => {
        /* WHY:
           Simulates network latency.
           Real app would call fetch()/XHR. */

        for (let i = 0; i < PAGE_SIZE; i++) {
          if (items.length >= MAX_ITEMS) break;
          items.push(`Item #${items.length + 1}`);
        }

        updateSpacerHeight();
        /* WHY:
           Scrollbar must grow when data grows.
           Without this â†’ incorrect scroll behavior. */

        render();
        /* WHY:
           Re-render visible window after data update. */

        isLoading = false;

        if (items.length >= MAX_ITEMS) {
          loadingEl.textContent = "No more items";
          observer.disconnect();
          /* WHY:
             Stop observing once all data is loaded.
             Prevents unnecessary callbacks. */
        }
      }, 500);
    }

    /* ===============================
       Virtualized Rendering
    =============================== */
    function render() {
      const scrollTop = scrollContainer.scrollTop;
      /* WHY:
         Determines which items should be visible. */

      const viewportHeight = scrollContainer.clientHeight;

      const visibleCount =
        Math.ceil(viewportHeight / ROW_HEIGHT);
      /* WHY:
         How many rows fit in viewport. */

      const startIndex = Math.max(
        Math.floor(scrollTop / ROW_HEIGHT) - BUFFER,
        0
      );
      /* WHY:
         Compute first visible index + buffer.
         Prevents flicker at boundaries. */

      const endIndex = Math.min(
        startIndex + visibleCount + BUFFER * 2,
        items.length
      );

      windowEl.innerHTML = "";
      /* WHY:
         Simple implementation.
         Alternative (better): DOM recycling for even less GC. */

      for (let i = startIndex; i < endIndex; i++) {
        const row = document.createElement("div");
        row.className = "row";
        row.textContent = items[i];
        windowEl.appendChild(row);
      }

      /* ðŸ”¥ GPU-ACCELERATED POSITIONING */
      windowEl.style.transform =
        `translateY(${startIndex * ROW_HEIGHT}px)`;
      /* WHY:
         Moves visible window without triggering layout.
         Alternative (bad): top / margin-top â†’ reflow + jank. */
    }

    function updateSpacerHeight() {
      spacer.style.height =
        `${items.length * ROW_HEIGHT}px`;
      /* WHY:
         Fake total height = total items Ã— row height.
         Scrollbar depends on this. */
    }

    /* ===============================
       Scroll Handling (rAF)
    =============================== */
    let ticking = false;

    scrollContainer.addEventListener("scroll", () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          render();
          ticking = false;
        });
        ticking = true;
      }
    });
    /* WHY:
       requestAnimationFrame ensures max 1 render per frame.
       Alternative: direct scroll handler â†’ layout thrashing. */

    /* ===============================
       Intersection Observer
       (WHEN to load data)
    =============================== */
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          fetchMoreItems();
        }
      },
      {
        root: scrollContainer,
        /* WHY:
           Observe within custom scroll container.
           Default viewport would be wrong here. */

        rootMargin: "0px 0px 300px 0px",
        /* WHY:
           Prefetch buffer.
           Loads data BEFORE user hits bottom. */

        threshold: 0
        /* WHY:
           Trigger as soon as sentinel is visible. */
      }
    );

    observer.observe(loadingEl);

    /* ===============================
       Initial Load
    =============================== */
    fetchMoreItems();
    /* WHY:
       Load first page on mount.
       Without this â†’ empty screen. */
  </script>

</body>
</html>


------------------> we can try using the pool of items <------------------
  function render() {
    const scrollTop = scrollContainer.scrollTop;
    const viewportHeight = scrollContainer.clientHeight;

    /**
     * WHY Math.ceil?
     * viewportHeight / ROW_HEIGHT may be fractional.
     * Example: 620px / 50px = 12.4 rows
     *
     * Math.ceil ensures we render the PARTIALLY visible row.
     * Without this â†’ blank gap at bottom of viewport.
     */
    const visibleCount =
      Math.ceil(viewportHeight / ROW_HEIGHT);

    /**
     * WHY Math.floor?
     * scrollTop / ROW_HEIGHT converts pixels â†’ row index.
     * Example: 120px / 50px = 2.4
     *
     * Math.floor ensures we start rendering
     * from the FIRST PARTIALLY visible row.
     *
     * Using Math.ceil here would SKIP rows â†’ flicker.
     */
    const startIndex = Math.max(
      Math.floor(scrollTop / ROW_HEIGHT) - BUFFER,
      0
    );

    /**
     * BUFFER * 2
     * - BUFFER rows above viewport
     * - BUFFER rows below viewport
     *
     * This hides scroll latency during fast scrolling.
     */
    const endIndex = Math.min(
      startIndex + visibleCount + BUFFER * 2,
      items.length
    );

    const requiredPoolSize = endIndex - startIndex;

    /* Ensure enough reusable rows exist */
    ensureRowPool(requiredPoolSize);

    /**
     * DOM REUSE:
     * Instead of creating/removing elements,
     * we update textContent of existing rows.
     */
    for (let i = 0; i < requiredPoolSize; i++) {
      const rowIndex = startIndex + i;
      const rowEl = rowPool[i];

      if (rowIndex < items.length) {
        rowEl.textContent = items[rowIndex];
        rowEl.style.display = "block";
      } else {
        rowEl.style.display = "none";
      }
    }

    /**
     * GPU-ACCELERATED POSITIONING
     * Moves the entire window to correct scroll position.
     *
     * WHY transform?
     * - No layout recalculation
     * - No reflow
     * - GPU compositing only
     */
    windowEl.style.transform =
      `translateY(${startIndex * ROW_HEIGHT}px)`;
  }
