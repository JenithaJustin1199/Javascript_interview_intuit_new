Revealing module pattern:
// Assign the result of an IIFE to `fn`
1. const fn = (function () {
  // ↑ This is an IIFE (Immediately Invoked Function Expression)
  // Why IIFE?
  // 1. Creates a private scope
  // 2. Executes immediately (one-time setup)
  // 3. Avoids polluting global scope
  // 4. Enables closure-based encapsulation (Revealing Module Pattern)

  // Private function — NOT accessible from outside
  function inner() {
    console.log("Hi");
  }

  // This function will be exposed publicly
  function getFunction() {
    // Returns the private `inner` function
    // Demonstrates closure: `inner` survives after IIFE execution
    return inner;
  }

  // Override the default toString() of `getFunction`
  // This controls how `getFunction` behaves during type coercion
  getFunction.toString = function () {
    // Accesses `inner` via closure
    // `inner` is private but still reachable here
    return "start:" + inner.toString() + ":end";
  };

  // Return only the public API
  // Everything else remains private inside the IIFE
  return getFunction;

  // After this point, the IIFE finishes execution
  // But the returned function still holds references (closure)
})();

// At this point:
// fn === getFunction
// inner is NOT accessible globally
// fn has a custom toString()

// --------------------------------------------

// When evaluating `1 + fn`:
console.log(1 + fn);

/*
Execution flow of `1 + fn`:

1. `+` operator with number + object
2. JS tries to convert `fn` to a primitive
3. Calls fn.valueOf() → returns object (ignored)
4. Calls fn.toString() → our overridden version runs
5. Returns:
   "start:function inner() { console.log("Hi"); }:end"
6. Number 1 is converted to string
7. Final result:
   "1start:function inner() { console.log("Hi"); }:end"
*/


--------------------------------------------------------------------------------------------------

2. const magicNumber = (function() {
  // Private number
  const value = 32;

  const obj = {};

  obj.valueOf = function() {
    return value; // used in numeric ops
  };

  obj.toString = function() {
    return `The answer is ${value}`;
  };

  return obj;
})();

console.log(magicNumber + 10);    // 42
console.log(magicNumber * 2);     // 64
console.log(String(magicNumber)); // "The answer is 32"

// Concept behind it:
| Operator/Method | Coercion Called                        |
| --------------- | -------------------------------------- |
| `+` (number)    | `valueOf()` then fallback `toString()` |
| `*`             | `valueOf()`                            |
| `String()`      | `toString()`                           |

--------------------------------------------------------------------------------------

3. function chainable(initialValue) {
  // Private state
  let currentValue = initialValue;

  // Revealing Module Pattern: expose only add/mul
  const api = {
    add(num) {
      currentValue += num;
      return api; // for chaining
    },
    mul(num) {
      currentValue *= num;
      return api; // for chaining
    },
    // Convert object to number for numeric operations
    valueOf() {
      return currentValue;
    },
    // Convert object to string for string coercion
    toString() {
      return `Result: ${currentValue}`;
    }
  };

  return api;
}
console.log(chainable(5).add(3).mul(2)); 
// valueOf is called in console → 16

console.log(chainable(5).add(3).mul(2) + 10); 
// valueOf() used in + → 16 + 10 = 26

console.log(String(chainable(5).add(3).mul(2))); 
// toString() → "Result: 16"

-----------------------------------------------------------------------------------------

4. function calc(initialValue) {
  let currentValue = initialValue;

  const api = {
    add(n) { currentValue += n; return api; },
    sub(n) { currentValue -= n; return api; },
    mul(n) { currentValue *= n; return api; },
    div(n) { currentValue /= n; return api; },
    value() { return currentValue; },
    valueOf() { return currentValue; },
    toString() { return `Result: ${currentValue}`; }
  };

  return api;
}

// Example
console.log(calc(5).add(3).mul(2).sub(4) + 0); // coerces to number → prints 12
console.log(String(calc(5).add(3).mul(2).sub(4))); // "Result: 12"

-----------------------------------------------------------------------------------
5. function add(...initialArgs) {
  // private sum
  let total = initialArgs.reduce((a, b) => a + b, 0);

  function inner(...args) {
    if (args.length === 0) return inner; // ignore empty calls if any
    total += args.reduce((a, b) => a + b, 0);
    return inner;
  }

  // Numeric coercion (console.log, +, *, etc.)
  inner.valueOf = function() {
    return total;
  };

  // String coercion (String(), template strings)
  inner.toString = function() {
    return `Sum: ${total}`;
  };

  return inner;
}
currying + Type coericision revealing pattern
console.log(add(2)(3)(4));      
// console.log tries to convert to string → calls toString() → "Sum: 9" 
// BUT **before printing**, Node/Chrome console ALSO tries valueOf() → 9  
// so you will see: 9

console.log(String(add(2)(3)(4))); 
// "Sum: 9"

------------------------------------------------------------

