1. Requirements (Clarify Scope)
Functional: Infinite scroll, rich media (video/images), social actions (like/comment), creating posts.
Non-Functional: Fast TTI (Time to Interactive), smooth scrolling, offline support, accessibility (a11y).

-> Infinit scroll
-> rich media
-> cache layer
-> like/comments


---> Infinite Scroll
1. Problem: Rendering a Really Long List
What happens if we render everything?
- Example: 50,000 rows
- Each row = DOM node

Browser work for each node:
1. Create DOM nodes
2. Style calculation
3. Layout (measure width/height)
4. Paint pixels
5. Composite layers
6. Re-run layout on every scroll

Performance impact:
- Memory: 50k rows ≈ 50–100MB DOM memory
- Layout time: 30–40ms per frame (bad)
- Target: 16ms per frame (60 FPS)
- Issues:
  - Layout thrashing
  - Slow initial render
  - Slow Time-To-Interactive
  - Scroll jank

Root cause: Too many DOM nodes + frequent re-layout

2. Core Idea: Virtualized List
Render only what the user sees, not everything

Key principle:
Rendered Items = Visible Items + Buffer

Example:
- Viewport height = 800px
- Row height = 40px
- Visible rows = 800 / 40 = 20 rows
- Add buffer: Render ~30–40 rows total (even if dataset has 50,000 items)

3. Why Do We Need a Buffer?
Problem without buffer:
- Scroll happens faster than render
- Visible window changes rapidly
- Causes: Flicker, Blank space

Solution: Overscan / Buffer
- Visible window: 100px → 120px
- Rendered window: 95px → 125px

Benefits:
- No empty gaps during fast scroll
- Smooth UX
- Browser always has content ready

4. Virtualized List Architecture
Outer Scroll Container (overflow: auto, fixed height)
├── Total Height Spacer (height = totalRows * rowHeight)
    └── Windowed Box (translated via transform)
        ├── Row Renderer
        ├── Row Renderer
        ├── Row Renderer
        └── ...

5. Role of Each Layer
1. Outer Scroll Container
   - Fixed height
   - overflow: auto
   - Handles native scrolling

2. Total Height Spacer
   - Single div
   - Height = totalRows × estimatedRowHeight
   - Makes scrollbar behave as if full list exists

3. Windowed Render Box
   - Contains only visible + buffer rows
   - Positioned using transform: translateY(startIndex * rowHeight)
   - Uses GPU acceleration

4. Item Renderer
   - Renders individual rows
   - Reused (recycled) instead of recreated

6. Why Use transform: translateY?
Bad: top / margin-top → triggers layout/reflow
Good: transform: translateY() → GPU accelerated, only compositing phase, no reflow
Critical for smooth scrolling

7. Scroll Handling Strategy
Problem: Scroll event fires too frequently → repeated state updates
Solution:
Scroll Event
↓
requestAnimationFrame
↓
Compute visible range
↓
Update transform

Benefits:
- Max one update per frame
- No layout thrashing
- Smooth 60 FPS

8. Optimizations in Virtualized Lists
1. Limit DOM Nodes: Keep constant (~30–40), independent of data size
2. Recycle DOM Nodes: Reuse row components, change content instead of destroy/create
3. GPU Accelerated CSS: transform, will-change: transform
4. Throttle Scroll: Use requestAnimationFrame (avoid setTimeout/debounce)

9. Fixed Height vs Dynamic Height Rows
Fixed Height (Preferred):
- Predictable math
- O(1) index → offset calculation
- No layout measurement
- offset = index * rowHeight

Dynamic Height Rows (Hard):
Problems:
- Browser must measure each row → forced layout
- Scroll position becomes inaccurate

Solutions:
1. Measure once
2. Cache heights
3. Never re-measure unnecessarily

10. Handling Dynamic Heights (Advanced)
Height Cache: index → measuredHeight
Prefix Sum / Fenwick Tree (Binary Indexed Tree):
- Compute total height before index i
- Update height: O(log n)
- Query scroll offset: O(log n)
- Efficient for large lists

11. Architecture Summary (Mental Model)
User Scrolls
↓
Compute visible index range
↓
Translate windowed box
↓
Recycle rows
↓
GPU paints only visible items

12. Key Interview One-Liners
- "Virtualization reduces DOM size, not data size"
- "Scrollbar is fake, content is real"
- "Transform avoids layout, top causes reflow"
- "Buffer prevents flicker during fast scroll"
- "Dynamic heights require prefix-sum structures"

13. When This Scales to Infinite Scroll
- Backend provides paginated data
- Frontend virtualizes rendering
- Data loading ≠ rendering
Infinite scroll = Data pagination + UI virtualization

---------------> Data fetching <---------------------
Cursor-based Pagination.
Send the ID/Timestamp of the last item seen: GET /feed?after=post_id_123.
The server returns the next set of items strictly after that specific post, 
ensuring stable pagination even if new items are added to the top.

------------------------------------->Intersection observer<------------------------
Intersection Observer → WHEN to load data
Virtualized List      → WHAT to render

Virtualized List solves:
- DOM explosion (too many nodes)
- Layout thrashing
- Staying within 16ms frame budget (60 FPS)
- Smooth scrolling with minimal rendered items + buffer

Benefits of Using Intersection Observer for Infinite Scroll
- No custom scroll calculations
- Browser-optimized visibility detection
- Reduced jank and layout thrashing
- Clean separation of concerns:
  - Virtualization: UI rendering efficiency
  - IO: Data loading triggers
- Preload upcoming data with rootMargin (e.g., 500px buffer)


-------------------------------> Rich media images <--------------
Downloading 50 high-res images at once kills bandwidth.
-> Lazy Loading: Use IntersectionObserver or <img loading="lazy" />.
Only fetch the image when it is ~200px away from the viewport. 
{ rootMargin: "200px" } like a buffer

observer = new IntersectionObserver(
  entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        img.src = img.dataset.src;
        observer.unobserve(img);
      }
    });
  },
  { rootMargin: "200px" }
);
-> Responsive Images: Use srcset to serve different sizes based on device width (320w, 720w). 
-> Modern Formats: Serve WebP or AVIF with a JPEG fallback. (add src-set to match the images with multiple device size)
-> BlurHash / Placeholders: Store a tiny base64 string (BlurHash) in the post metadata to show a blurred color blob immediately
while the image loads to prevent

---------------------> Caching Layer <--------------
The cache layer stores server responses so we don’t refetch the same data repeatedly and can serve it instantly on navigation.
It answers only these questions:
What do we store?
Where do we store it?
When do we reuse it?
When do we throw it away?
| Question                      | Feed Data (Posts, Feed Pages)                                                                                                                       | Images (Post Media)                                                                                                                       |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| **What do we store?**         | • Feed pages as **post ID lists**<br>• Normalized **post entities** (content, stats)<br>• Pagination cursors<br>• Metadata (lastFetchedAt)          | • **Image URLs & variants** (320w, 720w, WebP/JPEG)<br>• Image metadata (width, height, aspect-ratio)<br>• BlurHash / placeholder strings |
| **Where do we store it?**     | • **In-memory cache** (JS / query cache)<br>• Optional **persistent cache** (sessionStorage / IndexedDB)                                            | • **Browser HTTP cache** (primary)<br>• Optional **Service Worker cache** (advanced)<br>❌ Not in JS memory                                |
| **When do we reuse it?**      | • Navigate away → back to feed<br>• Scroll up/down within session<br>• Same post appears in multiple feeds<br>• Cache still within staleness window | • Same image URL requested again<br>• User scrolls back up<br>• Post appears multiple times<br>• Cache headers still valid                |
| **When do we throw it away?** | • Cache TTL expires<br>• Page limit exceeded (old pages evicted)<br>• Explicit invalidation (edit, delete)<br>• Logout                              | • Cache expiration (`max-age`)<br>• Storage quota eviction<br>• URL changes (hash-based invalidation)<br>• User clears browser cache      |

-----------------> What happens when the user likes the post <--------------
Social Action (Like) — Short Notes
1️⃣ Immediate UI Update (Frontend Cache Layer)
2️⃣ Backend Sync (Data Consistency Layer)

1️⃣ Immediate UI Update (Frontend Cache Layer)
Goal: Instant feedback, no waiting.
Frontend performs an optimistic update
Only the liked post entity in cache is updated
posts[postId].likedByMe = true
posts[postId].likeCount += 1
-> Rendering behavior
✅ Only that PostItem re-renders
❌ Feed list does NOT re-render
❌ No refetch

-> Why this works
Cache is normalized
UI subscribes to entity, not whole feed

2️⃣ Backend Sync (Data Consistency Layer)
Goal: Persist change + notify others.

A. API Call (Mandatory)
POST /posts/{id}/like
or
PUT /posts/{id}/reactions
Runs in parallel with UI update
Confirms or rejects optimistic change
On failure → rollback cache

---------------------------> Creation of POST <---------------------------------
-> Perceived Performance: Do you make the user wait? (Optimistic UI).
-> Reliability: What happens if the upload fails halfway? (Retries/Drafts).
-> Asset Management: Do you clog the application server with heavy video uploads? (Direct-to-Cloud uploads).
-> Security: Do you trust user input? (Sanitization).

A. The Upload Strategy (The "Presigned URL" Pattern) -> upload to s3 (pre-signed url)
B. Optimistic Updates & Queueing
      -> Immediate Feedback: As soon as the user clicks "Post", add the item to the Feed state locally with a "Pending" status.
      -> Background Sync: perform the API request in the background.
      Reconciliation:
      -> Success: Replace the local temporary ID with the real Server ID.
      -> Failure: Mark the post as "Failed" in the UI and offer a "Retry" button. Do not delete the user's text.
C. Handling Rich Text (Mentions & Hashtags)
LinkedIn isn't just plain text; 
it has mentions (@name) and hashtags (#topic).
Data Structure: Don't just save plain HTML (security risk). 
Use a structured format like Draft.js Raw or a custom JSON structure:
JSON
{
  "text": "Hello @Elon",
  "entities": [
    { "type": "mention", "offset": 6, "length": 5, "id": "user_123" }
  ]
}
The @ Trigger: You need a Trigger logic. When the user types @, detect the cursor position, open a PositionedOverlay, 
and fetch user suggestions (debounced).

D. Crash Recovery (Draft Saving)
The Scenario: The user types a long thought-leadership essay, and their browser crashes or they accidentally refresh. 
The Solution:
Local Storage / IndexedDB: Save the text content on every keystroke (debounced by 500ms) to localStorage.
Hydration: On mount, check localStorage for a draft key. If it exists, pre-fill the editor.

-----------------------> Performance <---------
1. Fast Time to Interactive (TTI)
2. Code Splitting & Lazy Loading:
3. Server-Side Rendering (SSR) / Static Site Generation (SSG):
4. <script> defer, async </script>
5. Service workers
6. Implement a Cache-First strategy for application assets (HTML, CSS, JS, logos). 
Implement a Stale-While-Revalidate strategy for the feed content itself.
7. Accessibility (A11Y)
    -> Semantic HTML:
    -> ARIA Attributes:
        For the "Like" button, use aria-label="Like post by [Author Name]" for clarity. Use aria-live="polite" for dynamic updates 
        (like a notification pop-up) so screen readers announce them.


------------------------> Communication Strategy <----------------------
| Communication Aspect | Protocol / Technique | Why it's Important |
| :--- | :--- | :--- |
| Initial Load | HTTP/2 or HTTP/3 | Faster parallel fetching of the first chunk of data and associated media. |
| Scrolling/Paging | REST/GraphQL (with Cursor) | Ensures stable, reliable fetching of the next page chunk. |
| Real-Time Push | SSE or WebSockets | Delivers "New Post" notifications or live counts without manual refreshing. |
| Efficiency | GraphQL | Allows clients to only fetch the exact fields they need, saving bandwidth. |
| Caching | HTTP Caching Headers (ETag, Cache-Control) | Reduces repeated transfers for static assets like post media and profile icons. |
