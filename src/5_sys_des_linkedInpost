# 1. Problem Statement (One-liner)

Design a **highly scalable, read-heavy social feed UI** that supports infinite scrolling, rich media, social interactions, and real-time updates for hundreds of millions of daily active users, while remaining fast, accessible, and resilient on unreliable networks.

---

# 2. Requirements (Clarify Scope – Short Notes)

## 2.1 Functional Requirements

* Infinite scrolling feed
* Render text, images, and videos (rich media)
* Social actions: like, comment, create post
* Real-time feed updates (new posts, counts)
* Offline and flaky-network support

## 2.2 Non-Functional Requirements

* Fast Time to Interactive
* Smooth sixty frames per second scrolling
* High perceived performance
* Strong accessibility support
* Scales to one billion users

---

# 3. Scale Assumptions (Interview Context)

* Total users: 1 billion
* Daily active users: ~400 million
* Read traffic is much higher than write traffic
* Feed is append-heavy and read-optimized

---

# 4. High-Level Front-End Architecture (With Responsibilities)

```
┌──────────────────────────────┐
│          Feed UI             │  ← Post list, media, actions
│ (Pure rendering components)  │
└───────────────┬──────────────┘
                │
┌───────────────▼──────────────┐
│   Virtualized Feed Renderer  │  ← Windowed rendering, buffer
│   (Scroll + Layout Engine)   │
└───────────────┬──────────────┘
                │
┌───────────────▼──────────────┐
│        Client Cache Layer    │  ← Normalized entities
│   In-memory + Persistent     │
└───────────────┬──────────────┘
     ┌──────────┼──────────┐
     │          │          │
┌────▼─────┐ ┌──▼────────┐ ┌▼─────────────────┐
│ Media     │ │ Sync      │ │ Service Worker   │
│ Loader    │ │ Manager   │ │ Cache + Offline  │
│ Lazy load │ │ REST + SSE│ │ Asset strategy   │
└────┬─────┘ └──┬────────┘ └──────────────────┘
     │            │
┌────▼────────┐ ┌▼─────────────────┐
│ Intersection │ │ Backend APIs      │
│ Observer     │ │ Feed / Actions    │
└──────────────┘ └──────────────────┘
```

---

# 5. Index – Front-End Design Roadmap (One-Liners)

1. Rendering Strategy – How the feed is painted
2. Infinite Scroll Model – Pagination vs rendering
3. Virtualized List – DOM size control
4. Data Fetching – Cursor-based pagination
5. Rich Media Loading – Images and video
6. Client Cache Layer – What and where to cache
7. Social Actions – Like and comment flow
8. Post Creation – Optimistic publishing
9. Real-Time Updates – Server push
10. Service Worker – Performance and offline
11. Performance Optimizations – Fast Time to Interactive
12. Accessibility – Inclusive interaction
13. Failure Handling – Resilience paths
14. Trade-offs – Explicit design choices

---

# 6. Detailed Front-End Design

---

## 6.1 Rendering Strategy

**One-liner:** Rendering efficiency matters more than data size.

### Approach

* Virtualized list renders only visible posts
* Constant number of Document Object Model nodes

**Why?**
Rendering thousands of posts directly causes layout thrashing and frame drops.

---

## 6.2 Infinite Scroll Model

**One-liner:** Infinite scroll is pagination plus virtualization.

### Backend Responsibility

* Cursor-based pagination using last seen post identifier or timestamp

### Frontend Responsibility

* Append data to cache
* Virtualize rendering

**Why cursor pagination?**
Stable even when new posts are inserted at the top.

---

## 6.3 Virtualized List (Core Performance Primitive)

**One-liner:** Render only what the user sees plus a buffer.

### Architecture

* Outer scroll container
* Total height spacer
* Windowed render box translated using transform

**Why transform?**
Transform is Graphics Processing Unit accelerated and avoids layout recalculation.

---

## 6.4 Data Fetching Strategy

**One-liner:** Fetch data incrementally and predictably.

### Techniques

* REST APIs for feed pages
* Intersection Observer to trigger next page load

**What is Intersection Observer?**
A browser API that asynchronously detects when an element enters the viewport.

---

## 6.5 Rich Media Loading

**One-liner:** Media must never block scrolling.

### Images

* Lazy loading with Intersection Observer
* Responsive images using srcset
* Modern formats like WebP or AVIF
* BlurHash placeholders for instant visual feedback

### Videos

* Poster images
* Autoplay only when visible

---

## 6.6 Client Cache Layer

**One-liner:** Cache data close to the user.

### What Is Cached

* Feed pages as lists of post identifiers
* Normalized post entities
* Pagination cursors

### Where It Is Cached

* In-memory cache for live state
* Indexed Database for persistence

**Why normalization?**
Ensures only affected posts re-render.

---

## 6.7 Social Actions (Like and Comment)

**One-liner:** Instant feedback through optimistic updates.

### Flow

* Update cache immediately
* Send API request
* Confirm or rollback

**Benefit:**
No feed-level re-render.

---

## 6.8 Post Creation

**One-liner:** Never block user creativity.

### Strategy

* Direct-to-cloud uploads using presigned URLs
* Optimistic feed insertion
* Background reconciliation

### Crash Recovery

* Draft saving using browser storage

---

## 6.9 Real-Time Updates

**One-liner:** Push updates instead of polling.

### Communication

* Server-Sent Events for new posts and counters

**Why Server-Sent Events?**
Feed is server-to-client only.

---

## 6.10 Service Worker Usage

**One-liner:** Control the network.

### Responsibilities

* Cache static assets using cache-first strategy
* Cache feed snapshots using stale-while-revalidate
* Enable offline viewing

---

## 6.11 Performance Optimizations

* Code splitting
* Lazy loading
* requestAnimationFrame batching
* Avoid unnecessary reflows

---

## 6.12 Accessibility

**One-liner:** Feed must work without a mouse.

### Practices

* Semantic HTML
* Accessible labels
* Live regions for updates

---

## 6.13 Failure Handling

| Scenario        | Strategy                   |
| --------------- | -------------------------- |
| Network failure | Serve cached feed          |
| Like failure    | Rollback optimistic update |
| Media failure   | Fallback placeholders      |

---

## 6.14 Trade-offs

| Decision           | Pros             | Cons            |
| ------------------ | ---------------- | --------------- |
| Virtualization     | Smooth scrolling | Complex logic   |
| Optimistic UI      | Fast UX          | Rollback needed |
| Server-Sent Events | Simple push      | One-directional |

---

# 7. Final Interview Summary

**“This feed design separates data pagination from rendering, uses virtualization to control Document Object Model size, applies optimistic updates for instant interactions, leverages Server-Sent Events for real-time delivery, and uses layered caching and service workers to ensure performance, accessibility, and reliability at massive scale.”**

This demonstrates **senior front-end system design maturity**.
