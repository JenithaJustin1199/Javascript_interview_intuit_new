# 1. Problem Statement (One-liner)

Design a **highly interactive, front-end heavy web calendar** that can render, edit, and synchronize time-based events accurately across multiple views, timezones, and devices, while scaling to thousands of events smoothly.

---

# 2. Requirements (Short Notes)

## 2.1 Functional Requirements

* Display calendar in Month, Week, Day, and Agenda views
* Create, edit, delete events
* Drag and resize events visually
* Support recurring events
* Handle overlapping events correctly
* Work across timezones
* Sync changes with backend
* Work in offline or flaky network conditions

## 2.2 Non-Functional Requirements

* Pixel-accurate rendering
* Smooth scrolling and interactions
* Correctness over animations
* Fast initial load
* Scalable to large event sets
* Accessible via keyboard and screen readers

---

# 3. Front-End Architecture Diagram (With Responsibilities)

```
┌──────────────────────────────┐
│        Calendar UI           │  ← Month / Week / Day / Agenda views
│  (Pure rendering components) │
└───────────────┬──────────────┘
                │
┌───────────────▼──────────────┐
│      View Layout Engine       │  ← Computes positions, sizes, overlaps
│  Grid | Overlap Resolver      │
└───────────────┬──────────────┘
                │
┌───────────────▼──────────────┐
│        Calendar Store         │  ← Single source of truth
│ Events | Instances | UI State │
└───────────────┬──────────────┘
   ┌────────────┼─────────────┐
   │            │             │
┌──▼─────────┐ ┌▼──────────┐ ┌▼────────────────┐
│ Interaction│ │ Sync       │ │ Timezone         │
│ Controller │ │ Manager    │ │ Controller       │
│ Drag/Resize│ │ REST       │ │ UTC ↔ Local      │
└──┬─────────┘ └┬──────────┘ └──────────────────┘
   │              │
┌──▼──────────┐  ┌▼────────────────┐
│ Rendering    │  │ Backend APIs     │
│ Scheduler    │  │ Events           │
│ requestFrame │  │                  │
└──────────────┘  └──────────────────┘
```

---

# 4. Screen-First Thinking (What Renders First)

## First Screen Strategy

* Render calendar grid immediately
* Show skeleton placeholders for events
* Hydrate events once data is ready

**Why skeletons?**
They preserve layout and prevent visual jumps.

---

# 5. Index – Front-End Design Roadmap (One-Liners)

1. Rendering Strategy – How views are painted
2. Data Model – Event vs instance separation
3. Timezone Handling – Correct time math
4. Layout Algorithm – Overlap resolution
5. Rendering Performance – Avoid reflows
6. Interaction Model – Drag, resize, select
7. Optimistic Updates – Instant feedback
8. Conflict Resolution – Concurrent edits
9. Recurrence Expansion – Visible range only
10. Scrolling Model – Sticky headers
11. Accessibility – Keyboard-first
12. Offline and Sync – Resilient UX
13. Failure Handling – Recovery paths
14. Trade-offs – Explicit decisions

---

# 6. Detailed Front-End Design

---

## 6.1 Rendering Strategy

**One-liner:** Calendar is layout-heavy, so layout computation is separated from rendering.

### Approach

* CSS Grid for time slots
* Absolute positioning for events

**Trade-offs:**

* Grid simplifies alignment
* Absolute positioning requires manual math

**Alternative:**

* Flexbox (less predictable for overlaps)

---

## 6.2 Data Model

**One-liner:** Separate persistent event data from view-specific instances.

### Event (Source of Truth)

```
{
  id,
  title,
  startUTC,
  endUTC,
  timezone,
  recurrenceRule
}
```

### Instance

* Generated per visible range
* Cached temporarily

**Why separation matters?**
Prevents recomputation on every render.

---

## 6.3 Time and Timezone Handling (Critical)

**One-liner:** Store in Coordinated Universal Time, render in local time.

### Rules

* Backend stores Coordinated Universal Time
* Frontend converts to local timezone
* Daylight Saving Time aware

**Why this matters?**
Timezone bugs break trust immediately.

---

## 6.4 Layout Algorithm (Overlapping Events)

**One-liner:** Resolve overlaps deterministically.

### Technique

* Sort events by start time
* Sweep through timeline
* Assign columns

**Alternative:**

* Interval trees (more complex)

---

## 6.5 Rendering Performance

**One-liner:** Only render what is visible.

### Techniques

* Virtualized rows
* Memoized layout calculations
* requestAnimationFrame batching

**What is requestAnimationFrame?**
A browser API that schedules rendering work before the next repaint.

---

## 6.6 Interaction Model

**One-liner:** All interactions must be pixel-accurate.

### Supported Interactions

* Click to create
* Drag to move
* Resize to extend

**Implementation**

* Pointer events
* Ghost elements during drag

---

## 6.7 Optimistic Updates

**One-liner:** UI updates immediately, backend confirms later.

### Flow

```
User action → Update UI → Send API → Confirm or rollback
```

**Trade-off:**
Fast UX vs revert complexity

---

## 6.8 Conflict Resolution

**One-liner:** Detect concurrent edits safely.

### Strategy

* Version numbers
* Last-write-wins
* User notification

---

## 6.9 Recurrence Rules

**One-liner:** Expand recurrence only for visible range.

**Why?**
Avoid infinite or expensive computation.

---

## 6.10 Scrolling Model

**One-liner:** Preserve spatial context.

### Features

* Sticky time column
* Sticky day headers
* Scroll position retention

---

## 6.11 Accessibility

**One-liner:** Calendar must not be mouse-only.

### Practices

* Keyboard navigation
* ARIA roles
* Screen reader labels

---

## 6.12 Offline and Sync

**One-liner:** Work without network.

### Strategy

* Cache events locally
* Queue mutations
* Sync when online

---

## 6.13 Failure Handling

| Failure           | Handling          |
| ----------------- | ----------------- |
| API error         | Retry or rollback |
| Timezone mismatch | Recompute layout  |
| Large data        | Pagination        |

---

## 6.14 Trade-offs Summary

| Decision             | Pros       | Cons          |
| -------------------- | ---------- | ------------- |
| CSS Grid             | Simple     | Less flexible |
| Absolute positioning | Precise    | Manual math   |
| Optimistic UI        | Fast       | Rollback      |
| Client recurrence    | Responsive | CPU cost      |

---

# 7. Final Interview Summary

**“This calendar design separates event data from layout computation, handles timezones safely, resolves overlaps deterministically, and delivers instant interactions through optimistic updates and virtualized rendering.”**

This signals **senior front-end system design thinking**.
