const obj = {
  a: 1,
  b: {
    c: 2,
    d: {
      e: 3
    }
  },
  f: 4
};
// with depth 1
{
  "a": 1,
  "b.c": 2,
  "b.d": { e: 3 },
  "f": 4
}
Flatten with depth = Infinity
{
  "a": 1,
  "b.c": 2,
  "b.d.e": 3,
  "f": 4
}
function flattenObject(obj, depth, parentKey = "", result = {}) {

  // Loop through all keys in the current object
  for (const key in obj) {

    // Build the new key:
    // If parentKey exists → "parent.child"
    // Else → "child"
    const newKey = parentKey ? `${parentKey}.${key}` : key;

    const value = obj[key];

    // Case 1:
    // If value is an object (not null, not array)
    // AND we still have depth left
    if (
      typeof value === "object" &&
      value !== null &&
      !Array.isArray(value) &&
      depth > 0
    ) {
      // Recursively flatten the nested object
      // Reduce depth by 1
      flattenObject(value, depth - 1, newKey, result);
    } else {
      // Case 2:
      // - Primitive value
      // - OR array
      // - OR depth limit reached
      // Store value as-is
      result[newKey] = value;
    }
  }

  // Return the accumulated flattened object
  return result;
}


