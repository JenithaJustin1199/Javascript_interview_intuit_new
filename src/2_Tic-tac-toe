/**
 * Entities (Internal State):
 * - board: Array representing the 3x3 grid.
 * - currentPlayer: String ('X' or 'O').
 * - isGameOver: Boolean flag.
 * - winner: String ('X', 'O', 'Draw', or null).
 */
class TicTacToeGame {
    constructor() {
        // Initialize the game state upon creation.
        this.board = Array(9).fill(null); 
        // 'X' is traditionally the starting player.
        this.currentPlayer = 'X'; 
        // Flag to prevent further moves after win/draw.
        this.isGameOver = false; 
        // Stores the winner ('X', 'O', or 'Draw').
        this.winner = null; 
        // Tracks the number of moves made (for draw detection).
        this.movesMade = 0; 
        // Define all 8 winning combinations (rows, columns, diagonals).
        // This is a static constant crucial for the checkWin logic.
        this.winningLines = [
            // Rows
            [0, 1, 2], [3, 4, 5], [6, 7, 8], 
            // Columns
            [0, 3, 6], [1, 4, 7], [2, 5, 8], 
            // Diagonals
            [0, 4, 8], [2, 4, 6]            
        ];
    }

    /**
     * Models (Public Getters): Provide read-only access to the state.
     */
    getBoard() {
        // Returns a copy of the board to prevent external modification.
        return [...this.board]; 
    }

    getCurrentPlayer() {
        // Returns the current player's symbol ('X' or 'O').
        return this.currentPlayer; 
    }

    getGameStatus() {
        // Returns an object containing the current game status.
        return { isGameOver: this.isGameOver, winner: this.winner }; 
    }

    /**
     * Methods (Core Logic): Handle state manipulation and game flow.
     */

    makeMove(index) {
        // 1. Validate index bounds and game status.
        if (index < 0 || index >= 9 || this.isGameOver) {
            // Return false if the move is invalid or the game is over.
            return false; 
        }

        // 2. Validate move availability.
        if (this.board[index] !== null) {
            // Return false if the cell is already occupied.
            return false; 
        }

        // --- Execute Valid Move ---
        // Record the move with the current player's symbol.
        this.board[index] = this.currentPlayer; 
        // Increment the total move count.
        this.movesMade++; 

        // 3. Check for Win or Draw immediately after the move.
        if (this.checkWin(index)) {
            // If checkWin returns true, set the winner and game status.
            this.isGameOver = true; 
            // The current player is the winner.
            this.winner = this.currentPlayer; 
        } else if (this.movesMade === 9) {
            // If board is full and no winner, it's a draw.
            this.isGameOver = true; 
            this.winner = 'Draw'; 
        } else {
            // 4. Switch player only if the game is not over.
            this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X'; 
        }

        // Return true to indicate a successful move.
        return true; 
    }

    /**
     * Core Algorithm: Efficiently checks for a win condition.
     * @param {number} lastMoveIndex - The index (0-8) of the cell just played.
     * MUST NOT iterate over the whole board; only check relevant lines.
     * @returns {boolean} True if the current player has won, false otherwise.
     */
    checkWin(lastMoveIndex) {
        // Get the symbol of the player who just moved.
        const symbol = this.board[lastMoveIndex]; 

        // Iterate through all defined winning lines.
        for (const line of this.winningLines) {
            // Check if the current winning line includes the last moved index.
            // This is slightly less efficient than pre-filtering, but very clear.
            if (line.includes(lastMoveIndex)) { 
                // Check if all three cells in this line match the symbol.
                // This is the O(1) part for a 3x3 board.
                if (
                    this.board[line[0]] === symbol &&
                    this.board[line[1]] === symbol &&
                    this.board[line[2]] === symbol
                ) {
                    // Found a winning line.
                    return true; 
                }
            }
        }

        // No winning line found for the player who just moved.
        return false; 
    }

    resetGame() {
        // Reset all internal state variables to start a new game.
        this.board.fill(null); 
        this.currentPlayer = 'X'; 
        this.isGameOver = false; 
        this.winner = null; 
        this.movesMade = 0; 
    }
}

// --- Example Usage (Not part of the class, just for demonstration) ---
// const game = new TicTacToeGame();
// console.log(game.getBoard()); // [null, null, ...]
// game.makeMove(0); // X plays top-left
// game.makeMove(4); // O plays center
// game.makeMove(1); // X plays top-center
// game.makeMove(8); // O plays bottom-right
// console.log(game.makeMove(2)); // X wins! Returns true
// console.log(game.getGameStatus()); // { isGameOver: true, winner: 'X' }



--------------------------> N X N <---------------------------------

/**
 * Class representing the pure Game Logic for an N x N Tic-Tac-Toe game.
 * It uses incremental tracking for O(1) win checking.
 */
class TicTacToeGameN {
    /**
     * Constructor initializes the game state and N-sized counter arrays.
     * @param {number} N - The dimension of the square board (e.g., 3 for 3x3).
     */
    constructor(N) {
        this.N = N; // Store the board dimension N.
        this.board = Array(N * N).fill(null); // 1D array representing the N*N grid.
        this.currentPlayer = 'X'; // Start with player 'X'.
        this.isGameOver = false; // Initial game state.
        this.winner = null; // Stores 'X', 'O', 'Draw', or null.
        this.movesMade = 0; // Tracks total moves for draw condition.

        // --- O(1) Win Check Counters ---
        // Initialize N-sized arrays to track progress in each row and column.
        this.rowCounts = Array(N).fill(0); 
        this.colCounts = Array(N).fill(0);
        
        // Diagonals: [0] for Main (r=c), [1] for Anti (r+c = N-1).
        this.diagCounts = [0, 0];
    }

    /**
     * Public getter for the board state (returns a copy).
     */
    getBoard() {
        return [...this.board];
    }

    /**
     * Public getter for the current player.
     */
    getCurrentPlayer() {
        return this.currentPlayer;
    }

    /**
     * Public getter for the game status.
     */
    getGameStatus() {
        return { isGameOver: this.isGameOver, winner: this.winner };
    }

    /**
     * Attempts to place the current player's mark at the given index.
     * @param {number} index - The 1D index (0 to N*N - 1) of the cell.
     * @returns {boolean} True if the move was successful, false otherwise.
     */
    makeMove(index) {
        // 1. Basic Validation: Check if game is over or index is out of bounds.
        if (this.isGameOver || index < 0 || index >= this.N * this.N) {
            return false;
        }

        // 2. Availability Validation: Check if the cell is already occupied.
        if (this.board[index] !== null) {
            return false;
        }

        // --- Move Execution ---
        
        // Update the board and move count.
        this.board[index] = this.currentPlayer;
        this.movesMade++;
        
        // Define the value for incremental tracking: X=1, O=-1.
        const value = this.currentPlayer === 'X' ? 1 : -1;
        
        // Convert 1D index to 2D coordinates (crucial for N x N).
        const row = Math.floor(index / this.N);
        const col = index % this.N;

        // --- Incremental Tracking (The O(1) Optimization) ---
        
        // 1. Update Row and Column Counters
        this.rowCounts[row] += value;
        this.colCounts[col] += value;

        // 2. Update Diagonals (only if the move is on a diagonal)
        
        // Main Diagonal check (row equals column)
        if (row === col) {
            this.diagCounts[0] += value;
        }
        
        // Anti-Diagonal check (row + column equals N - 1)
        if (row + col === this.N - 1) {
            this.diagCounts[1] += value;
        }

        // --- Check Game Status ---

        // Check win condition using the O(1) counters.
        if (this.checkWin(row, col)) {
            this.isGameOver = true;
            this.winner = this.currentPlayer;
        } else if (this.movesMade === this.N * this.N) {
            // Check for a Draw (board is full).
            this.isGameOver = true;
            this.winner = 'Draw';
        } else {
            // Switch to the next player.
            this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
        }

        return true;
    }

    /**
     * O(1) Win Check using the incremental counters.
     * @param {number} row - The row of the last move.
     * @param {number} col - The column of the last move.
     * @returns {boolean} True if a win is detected on the row, column, or diagonal.
     */
    checkWin(row, col) {
        // The target absolute value for a win is the board dimension N.
        const targetAbs = this.N;

        // Check Row Win (O(1) lookup)
        if (Math.abs(this.rowCounts[row]) === targetAbs) {
            return true;
        }
        
        // Check Column Win (O(1) lookup)
        if (Math.abs(this.colCounts[col]) === targetAbs) {
            return true;
        }

        // Check Main Diagonal Win (O(1) lookup, only if the move was on it)
        if (row === col && Math.abs(this.diagCounts[0]) === targetAbs) {
            return true;
        }
        
        // Check Anti-Diagonal Win (O(1) lookup, only if the move was on it)
        if (row + col === this.N - 1 && Math.abs(this.diagCounts[1]) === targetAbs) {
            return true;
        }

        // No win detected in this move.
        return false;
    }

    /**
     * Resets the game to its initial state.
     */
    resetGame() {
        this.board.fill(null);
        this.currentPlayer = 'X';
        this.isGameOver = false;
        this.winner = null;
        this.movesMade = 0;
        this.rowCounts.fill(0);
        this.colCounts.fill(0);
        this.diagCounts = [0, 0];
    }
}

// --- Example of 4x4 Game Usage ---
/*
const game = new TicTacToeGameN(4);
// X plays (0, 0)
game.makeMove(0);
// O plays (1, 0)
game.makeMove(4);
// X plays (0, 1)
game.makeMove(1);
// O plays (1, 1)
game.makeMove(5);
// X plays (0, 2)
game.makeMove(2);
// O plays (1, 2)
game.makeMove(6);
// X plays (0, 3) -> X wins on Row 0!
game.makeMove(3); 
console.log(game.getGameStatus()); // { isGameOver: true, winner: 'X' }
*/

------------> HTML <-----------
<div id="game-container">
    <h2>Tic-Tac-Toe: Player <span id="current-player">X</span>'s Turn</h2>
    <div id="board" class="tic-tac-toe-board">
        </div>
    <div id="status-message"></div>
    <button id="reset-button">Start New Game</button>
</div>

----------> CSS <--------------
/* General Layout */
#game-container {
    font-family: Arial, sans-serif;
    text-align: center;
}

/* The Board Container */
.tic-tac-toe-board {
    /* Use JavaScript to set the grid columns dynamically */
    display: grid; 
    width: fit-content;
    margin: 20px auto;
    border: 3px solid #333;
}

/* Individual Cell Styling */
.cell {
    width: 80px;  /* Example size */
    height: 80px; /* Example size */
    border: 1px solid #ccc;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 48px;
    font-weight: bold;
    cursor: pointer; /* Indicates interactivity */
    user-select: none;
}

/* Highlight the winner */
.winner-cell {
    background-color: #d4edda;
    color: #155724;
}

/* Disable interaction when game is over */
.game-over .cell {
    cursor: default;
}

/* Status message style */
#status-message {
    margin-top: 15px;
    font-size: 1.2em;
    min-height: 20px;
}
-------> JS <-------
// Assume the TicTacToeGameN class is defined above this code.

const N = 4; // Example N x N board size
const game = new TicTacToeGameN(N); // Initialize the Game Logic

// --- DOM Element References ---
const boardElement = document.getElementById('board');
const statusMessageElement = document.getElementById('status-message');
const currentPlayerElement = document.getElementById('current-player');
const resetButton = document.getElementById('reset-button');

/**
 * 1. RENDER INITIAL BOARD (O(N^2))
 * Creates all cell elements based on the board size N.
 */
function initializeBoard() {
    // Set the dynamic grid columns using CSS Grid property.
    boardElement.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
    
    // Clear any previous cells.
    boardElement.innerHTML = '';
    
    // Create N*N cells.
    for (let i = 0; i < N * N; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        // IMPORTANT: Store the 1D index as a data attribute for retrieval in the click handler.
        cell.dataset.index = i; 
        boardElement.appendChild(cell);
    }
    
    // Initial UI update.
    updateUI();
}

/**
 * 2. UPDATE UI (O(N^2))
 * Syncs the visual state of the board and status messages with the Game Logic state.
 */
function updateUI() {
    const boardState = game.getBoard();
    const status = game.getGameStatus();

    // Update Player Turn display
    currentPlayerElement.textContent = game.getCurrentPlayer();
    
    // Update Cell Contents
    const cells = boardElement.querySelectorAll('.cell');
    cells.forEach((cell, index) => {
        // Render 'X' or 'O' or nothing.
        cell.textContent = boardState[index] || ''; 
        // Remove old winner highlights
        cell.classList.remove('winner-cell');
    });

    // Update Status Message and Game Over State
    if (status.isGameOver) {
        boardElement.classList.add('game-over');
        if (status.winner === 'Draw') {
            statusMessageElement.textContent = 'Game Over! It\'s a Draw!';
        } else {
            statusMessageElement.textContent = `Game Over! Player ${status.winner} Wins!`;
            // Optional: You could add logic here to highlight the winning line.
        }
    } else {
        boardElement.classList.remove('game-over');
        statusMessageElement.textContent = ''; // Clear message during play.
    }
}

/**
 * 3. INTERACTION (Event Delegation)
 * Single handler for all cell clicks.
 */
boardElement.addEventListener('click', (event) => {
    // 1. Ensure the click target is a cell element.
    const target = event.target;
    if (!target.classList.contains('cell')) {
        return; // Ignore clicks on the board container itself or other elements.
    }

    // 2. Get the index from the data attribute.
    const index = parseInt(target.dataset.index);
    
    // 3. Pass the move to the pure Game Logic class.
    const moveSuccessful = game.makeMove(index);

    // 4. If the move was valid, update the UI.
    if (moveSuccessful) {
        updateUI();
    }
});

/**
 * 4. RESET BUTTON HANDLER
 */
resetButton.addEventListener('click', () => {
    game.resetGame(); // Reset the state
    initializeBoard(); // Re-render the fresh board
});


// --- Initialization ---
initializeBoard(); // Start the game when the script loads.
